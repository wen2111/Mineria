---
title: "Preprocessing Univ"
output:
  pdf_document:
    toc: true
  html_document:
    toc: true
    toc_float: true
    number_sections: true
date: "2025-10-01"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

El objetivo de este análisis es compararlo con el previo a la imputación, y comprovar si ha habido cambios.
# Detección de outliers univariante: variables numéricas
```{r, include=FALSE}
library(lawstat)
library(ggplot2)
library(moments)
library(EnvStats)
library(here)
library(rstudioapi)
load("~/GitHub/Mineria/DATA/dataaaaaaaaaaaaaa.RData")
load("~/GitHub/Mineria/DATA/data.RData")

```
Variables a estudiar:
```{r}
varNum<-c("Age", "CreditScore", "Tenure","EstimatedSalary", "Balance", "NumOfProducts",
          "TransactionFrequency","AvgTransactionAmount","DigitalEngagementScore",
          "ComplaintsCount","NetPromoterScore")
```
## Simetría de las variables
Primero haremos una comparación entre los estadísticos de simetría para cada variable.
```{r}
tabla_comparacion <- data.frame(
  Skewness_Antes = round(sapply(varNum, function(v) skewness(data[[v]], na.rm = TRUE)), 3),
  Skewness_Despues = round(sapply(varNum, function(v) skewness(data_imputado[[v]])), 3),
  Diferencia = round(sapply(varNum, function(v) {
    skewness(data_imputado[[v]]) - skewness(data[[v]], na.rm = TRUE)
  }), 3)
)

print(tabla_comparacion)
```
Los resultados son prácticamente idénticos y las diferencias asignables a la aleatoriedad. Se observa un cambio mayor en Avg transaction amount, aunque a nivel visual ambas distribuciones son idénticas, y en cualquier caso continúa siendo muy asimétrica.

El análisis de las distribuciones será el mismo que en el análisis previo, puesto que en la visualización de las distribuciones previas y posteriores a la imputación se observa que son prácticamente idénticas.

Ahora procedemos a dividir nuestras variables numéricas en simétricas y no simétricas para continuar con el análisis adecuado en cada caso:

```{r}
symmetric<-c("TransactionFrequency", "Tenure", "EstimatedSalary", "CreditScore")
non_symmetric<-c("Age","AvgTransactionAmount","DigitalEngagementScore", "NetPromoterScore")
varNum
```

## Outliers variables simétricas

Procedemos a la detección de outliers para las variables simétricas. Para ello utilizaremos el rango intercuartílico (IQR), de modo que los valores que queden fuera de dicho intervalo serán reconocidos como outliers univariantes
```{r}
data<-data_imputado
outlier_positions <- list()
IQROutlier <- function(variable, rmnas = TRUE) {
  IQ <- IQR(variable, na.rm = rmnas)
  intInf <- quantile(variable, probs = c(0.25, 0.75),na.rm = rmnas)[[1]] - 1.5*IQ
  intSup <- quantile(variable, probs = c(0.25, 0.75),na.rm = rmnas)[[2]] + 1.5*IQ
  posicions <- which(variable >= intSup | variable <= intInf)
  if (length(posicions) > 0) {
    cat("Existen outliers en las posiciones:", paste0(posicions, collapse = ", "))
  } else {
    cat("No existen outliers")
  }
  return(posicions)
}
for (var in symmetric) {
  cat("\nVariable:", var, "\n")
  pos <- IQROutlier(data[[var]])
  if (length(pos) > 0) {
    outlier_positions[[var]] <- pos
  }
}

outlier_positions
longitudes_s <- sapply(outlier_positions, length)
longitudes_s
```
Vemos como el resultado es exactamente el mismo que en el análisis previo, añadiendo aproximadamente un 30% a cada variable. Estos son los outliers que podíamos considerar como naturales. Es buena señal que el número aumente proporcionalmente al del número de datos al haber imputado el 30% de NA.

## Outliers variables no simétricas

Utilizaremos el mismo método que en el análisis previo.
```{r}
hampelOutlier <- function(variable, mad_constant = 1, threshold = 3.5) {
  med <- median(variable, na.rm = TRUE)
  mad_val <- mad(variable, constant = mad_constant, na.rm = TRUE)
  
  lower_bound <- med - threshold * mad_val
  upper_bound <- med + threshold * mad_val
  
  which((variable < lower_bound) | (variable > upper_bound))
}

outlier_positions_non_symmetric <- list()

for (var in non_symmetric) {
  outliers <- hampelOutlier(data[[var]])
  if (length(outliers) > 0) {
    outlier_positions_non_symmetric[[var]] <- outliers
  }
}

outlier_positions_non_symmetric
longitudes_ns <- sapply(outlier_positions_non_symmetric, length)
longitudes_ns
```
Misma conclusión que para las variables simétricas: el aumento de outliers es proporcional al aumento de datos y sigue estando dentro del recuento aceptable. 

## Verificación por proporciones respecto a la variable salida

Ahora haremos una comparación de las proporciones segun el grupo (train o test) para evaluar si hay alguna anomalía.
```{r}
prop_test <- 30
prop_train <- 70
todas_outliers<-c(outlier_positions, outlier_positions_non_symmetric)
proporcion_outliers_completa <- data.frame(
  Variable = character(),
  Grupo = character(),
  N_Outliers = integer(),
  Total_Outliers = integer(),
  Proporcion_Outliers = numeric(),
  Proporcion_Esperada = numeric(),
  Diferencia = numeric(),
  stringsAsFactors = FALSE
)

for (var in names(todas_outliers)) {
  outliers <- todas_outliers[[var]]
  total_outliers_var <- length(outliers)
  
  if (total_outliers_var > 0) {
    outliers_test <- sum(data$group[outliers] == "test")
    outliers_train <- sum(data$group[outliers] == "train")
    
    proporcion_outliers_completa <- rbind(proporcion_outliers_completa,
      data.frame(
        Variable = var,
        Grupo = "test",
        N_Outliers = outliers_test,
        Total_Outliers = total_outliers_var,
        Proporcion_Outliers = round(outliers_test / total_outliers_var * 100, 1),
        Proporcion_Esperada = round(prop_test, 1),
        Diferencia = round((outliers_test / total_outliers_var * 100) - prop_test, 1)
      ),
      data.frame(
        Variable = var,
        Grupo = "train", 
        N_Outliers = outliers_train,
        Total_Outliers = total_outliers_var,
        Proporcion_Outliers = round(outliers_train / total_outliers_var * 100, 1),
        Proporcion_Esperada = round(prop_train, 1),
        Diferencia = round((outliers_train / total_outliers_var * 100) - prop_train, 1)
      )
    )
  }
}

# Mostrar resultados
proporcion_outliers_completa
```
Las proporciones se mantienen

## Detección de valores imposibles

Ahora haremos un summary de las variables donde hemos detectado outliers para determinar si hay valores imposibles (como una persona con edad 180).

```{r}
variables_con_outliers <- names(todas_outliers)
summary(data[variables_con_outliers])
```
Sigue sin haber valores imposibles

## Conclusión del análisis de outliers post imputación

- Se respetan las proporciones previas.
- Sigue sin haber valores imposibles.
- Son outliers que se pueden aceptar como normales.

Estas conclusiones sumadas al análisis del ajuste de la distribución imputada nos permiten **validar** la imputación multivariante mediante el método MICE.
