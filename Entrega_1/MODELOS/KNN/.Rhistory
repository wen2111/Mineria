fn_cmtbl <- file.path(export_dir, paste0("confusion_table_", base_name, ".csv"))
write.csv(df_cm_tbl, fn_cmtbl, row.names = FALSE)
df_cm_stats <- data.frame(t(c(
Accuracy    = as.numeric(cm$overall["Accuracy"]),
Kappa       = as.numeric(cm$overall["Kappa"]),
Precision   = as.numeric(cm$byClass["Pos Pred Value"]),
Recall      = as.numeric(cm$byClass["Sensitivity"]),
Specificity = as.numeric(cm$byClass["Specificity"]),
F1          = 2*as.numeric(cm$byClass["Pos Pred Value"])*as.numeric(cm$byClass["Sensitivity"]) /
(as.numeric(cm$byClass["Pos Pred Value"]) + as.numeric(cm$byClass["Sensitivity"]))
)))
fn_cmstats <- file.path(export_dir, paste0("confusion_stats_", base_name, ".csv"))
write.csv(df_cm_stats, fn_cmstats, row.names = FALSE)
# puntos ROC del test
roc_df <- data.frame(
threshold = roc_obj$thresholds,
tpr       = roc_obj$sensitivities,
fpr       = 1 - roc_obj$specificities
)
fn_roc <- file.path(export_dir, paste0("roc_points_", base_name, ".csv"))
write.csv(roc_df, fn_roc, row.names = FALSE)
# 4) coordenadas FAMD del test (por si quieres reproducir vecinos/plots)
Xte_dump <- cbind(id=ids, Xte_coord)
fn_xte <- file.path(export_dir, paste0("Xte_FAMD_", base_name, ".csv"))
write.csv(Xte_dump, fn_xte, row.names = FALSE)
invisible(NULL)
}
f1_from_cm <- function(cm){
p <- as.numeric(cm$byClass["Pos Pred Value"])
r <- as.numeric(cm$byClass["Sensitivity"])
2*p*r/(p+r)
}
myROC <- function(data, lev=NULL, model=NULL){
twoClassSummary(data, lev = c("Yes","No"))
}
make_row <- function(balancea, fit, cm, ...) {
data.frame(
Balancea   = balancea, Método = "KNN",
Accuracy   = as.numeric(cm$overall["Accuracy"]),
Precision  = as.numeric(cm$byClass["Pos Pred Value"]),
Recall..S. = as.numeric(cm$byClass["Sensitivity"]),
Specifici  = as.numeric(cm$byClass["Specificity"]),
F1.score   = {
p <- as.numeric(cm$byClass["Pos Pred Value"])
r <- as.numeric(cm$byClass["Sensitivity"])
2*p*r/(p+r)
},
DATA       = NA_character_,
k_opt      = fit$bestTune$k,
ncp_used   = NA_integer_,
check.names = FALSE
)
}
out <- list()
## 9) En el conjunto no balanceado, buscar rápidamente k0
ctrl5 <- trainControl(method="cv", number=5,
classProbs=TRUE, summaryFunction=myROC)
set.seed(123)
fit_coarse <- train(x=X_tr, y=y_tr, method="knn",
trControl=ctrl5, metric="ROC",
tuneGrid=data.frame(k=k_grid_coarse))
k0 <- fit_coarse$bestTune$k
k_refine <- sort(unique(pmax(1, k0 + (-k_refine_span:k_refine_span))))
set.seed(123)
fit_base <- train(x=X_tr, y=y_tr, method="knn",
trControl=ctrl5, metric="ROC",
tuneGrid=data.frame(k=k_refine))
# Accuracy
ctrl_acc <- trainControl(method="cv", number=5)
fit_coarse_acc <- train(x=X_tr, y=y_tr, method="knn",
trControl=ctrl_acc, metric="Accuracy",
tuneGrid=data.frame(k = k_grid_coarse))
with(fit_coarse_acc$results,
plot(k, Accuracy, type="b", pch=16, xlab="k (coarse grid)", ylab="Accuracy (CV)"))
pred_base <- predict(fit_base, newdata=X_te)
prob_base <- predict(fit_base, newdata=X_te, type="prob")[,"Yes"]
roc_base  <- pROC::roc(response=y_te, predictor=prob_base,
levels=c("No","Yes"), direction="<")
auc_ext_base <- as.numeric(pROC::auc(roc_base))
cm_base   <- confusionMatrix(pred_base, y_te, positive="Yes")
# exportar baseline
write_test_bundle(balance_label = "No",
fit=fit_base, pred=pred_base, prob=prob_base,
cm=cm_base, roc_obj=roc_base,
ids=test_ids, y_true=y_te,
Xte_coord=X_te, tag="test")
auc_cv_base <- max(fit_base$results$ROC, na.rm=TRUE)
out[[length(out)+1]] <- cbind(make_row("No", fit_base, cm_base),
data.frame(AUC_ext=auc_ext_base, Gap_AUC=fit_base$results$ROC[fit_base$results$k==fit_base$bestTune$k] - auc_ext_base))
# ——— aplicar esquemas de balanceo con k_best fijo ———
k_best <- fit_base$bestTune$k
one_sampling <- function(samp){
set.seed(123)
ctrl_s <- trainControl(method="cv", number=5,
classProbs=TRUE, summaryFunction=myROC,
sampling=samp)
fit <- train(x=X_tr, y=y_tr, method="knn",
trControl=ctrl_s, metric="ROC",
tuneGrid=data.frame(k=k_best))
pred <- predict(fit, X_te)
prob <- predict(fit, X_te, type="prob")[,"Yes"]
roc_s <- pROC::roc(response=y_te, predictor=prob,
levels=c("No","Yes"), direction="<")
auc_ext <- as.numeric(pROC::auc(roc_s))
cm  <- confusionMatrix(pred, y_te, positive="Yes")
auc_cv <- max(fit$results$ROC, na.rm=TRUE)
# exportar por esquema
write_test_bundle(balance_label = paste0("Si:",samp),
fit=fit, pred=pred, prob=prob,
cm=cm, roc_obj=roc_s,
ids=test_ids, y_true=y_te,
Xte_coord=X_te, tag="test")
make_row(paste0("Si:",samp), fit, cm, auc_cv, auc_ext)
}
for (samp in sampling_vec_fast) out[[length(out)+1]] <- one_sampling(samp)
if (run_smote) out[[length(out)+1]] <- one_sampling("smote")
if (run_rose)  out[[length(out)+1]] <- one_sampling("rose")
do.call(rbind, out)
}
ncp_map <- list(Imputado=19, reducido=8, reducido_plus=10, transformada=28)
res_knn_imputado      <- run_knn(data_imputado,      "Imputado",      res.famd_imp, ncp_map$Imputado)
res_knn_imputado      <- run_knn(data_imputado,      "Imputado",      res.famd_imp, ncp_map$Imputado)
library(caret)
library(FactoMineR)
library(ROSE)
library(pROC)
set.seed(123)
# load("C:/Users/95409/OneDrive/ESTADISTICA/4r/1/MD/Mineria/Entrega_1/famd/famd_data.Rdata")
f1_from_cm <- function(cm){
p <- as.numeric(cm$byClass["Pos Pred Value"])
r <- as.numeric(cm$byClass["Sensitivity"])
2*p*r/(p+r)
}
myROC <- function(data, lev=NULL, model=NULL){
twoClassSummary(data, lev = c("Yes","No"))
}
run_knn <- function(
data_df, data_name, res_famd, ncp_fixed,
sampling_vec_fast = c("down","up"),   # under/over-sampling
k_grid_coarse = seq(1, 7, 2),
k_refine_span = 2,
run_smote = FALSE, run_rose = FALSE,
export_dir = "exports_knn",           # 修复：缺逗号 & 新增导出参数
export_preds = TRUE
){
dir.create(export_dir, showWarnings = FALSE, recursive = TRUE)
## ============ 统一列模板，避免 rbind 报错 ============
.master_cols <- c(
"Balancea","Método","Accuracy","Precision","Recall..S.","Specifici",
"F1.score","DATA","k_opt","AUC_cv","AUC_ext","Gap_AUC","ncp_used"
)
.ensure_cols <- function(df){
miss <- setdiff(.master_cols, colnames(df))
if (length(miss)) df[, miss] <- NA
extra <- setdiff(colnames(df), .master_cols)
if (length(extra)) df <- df[, setdiff(colnames(df), extra), drop = FALSE]
df <- df[, .master_cols, drop = FALSE]
rownames(df) <- NULL
df
}
## 1) 训练子集 & 统一正负类
d <- subset(data_df, group == "train")
d$Exited <- factor(ifelse(as.character(d$Exited) == "1", "Yes", "No"),
levels = c("Yes","No"))
## 2) 从 FAMD 抽取激活变量与训练行名
famd_vars      <- colnames(res_famd$call$X)
famd_train_ids <- rownames(res_famd$ind$coord)
## 3) 保持与 FAMD 一致的列
d_f <- d[, c(famd_vars, "Exited"), drop = FALSE]
if (is.null(rownames(d_f))) rownames(d_f) <- make.unique(sprintf("r%05d", seq_len(nrow(d_f))))
## 4) 对齐行顺序（FAMD 中出现的 = 训练；其余 = 内部 test）
all_ids    <- rownames(d_f)
common_ids <- famd_train_ids[famd_train_ids %in% all_ids]
test_ids   <- setdiff(all_ids, common_ids)
## 5) y_tr / y_te
y_tr <- d_f[common_ids, "Exited", drop = TRUE]
y_te <- d_f[test_ids,  "Exited", drop = TRUE]
## 6) 训练特征（直接用 FAMD 坐标）；测试特征（predict 到 FAMD 坐标）
ncp_fixed <- min(ncp_fixed, ncol(res_famd$ind$coord))
X_tr <- as.data.frame(res_famd$ind$coord[common_ids, 1:ncp_fixed, drop = FALSE])
colnames(X_tr) <- paste0("F", seq_len(ncol(X_tr)))
X_te_raw <- d_f[test_ids, famd_vars, drop = FALSE]
X_tr_raw <- d_f[common_ids, famd_vars, drop = FALSE]
for (v in famd_vars) {
if (is.factor(X_tr_raw[[v]])) {
X_te_raw[[v]] <- factor(X_te_raw[[v]], levels = levels(X_tr_raw[[v]]))
}
}
X_te <- as.data.frame(predict(res_famd, newdata = X_te_raw)$coord[, 1:ncp_fixed, drop = FALSE])
colnames(X_te) <- paste0("F", seq_len(ncol(X_te)))
## 8) 安全检查
stopifnot(nrow(X_tr) == length(y_tr))
stopifnot(nrow(X_te) == length(y_te))
## 统一行构造
make_row <- function(balancea, fit, cm, data_name, ncp_fixed,
auc_cv = NA_real_, auc_ext = NA_real_){
p <- as.numeric(cm$byClass["Pos Pred Value"])
r <- as.numeric(cm$byClass["Sensitivity"])
data.frame(
Balancea   = balancea, Método="KNN",
Accuracy   = as.numeric(cm$overall["Accuracy"]),
Precision  = p,
Recall..S. = r,
Specifici  = as.numeric(cm$byClass["Specificity"]),
F1.score   = 2*p*r/(p+r),
DATA       = data_name,
k_opt      = fit$bestTune$k,
AUC_cv     = auc_cv,
AUC_ext    = auc_ext,
Gap_AUC    = auc_cv - auc_ext,
ncp_used   = ncp_fixed,
check.names = FALSE
)
}
## 导出工具：逐行预测/混淆矩阵/ROC 点/FAMD 坐标
write_test_bundle <- function(balance_label, fit, pred, prob, cm, roc_obj,
ids, y_true, Xte_coord, tag){
if (!export_preds) return(invisible(NULL))
kopt <- fit$bestTune$k
base_name <- paste0(data_name, "__", gsub("[ :]", "", balance_label),
"__k", kopt, "__ncp", ncp_fixed, "__", tag)
df_pred <- data.frame(
id        = ids,
DATA      = data_name,
balance   = balance_label,
k         = kopt,
ncp_used  = ncp_fixed,
y_true    = y_true,
y_pred    = pred,
prob_yes  = prob,
stringsAsFactors = FALSE
)
write.csv(df_pred, file.path(export_dir, paste0("preds_", base_name, ".csv")), row.names = FALSE)
write.csv(as.data.frame(cm$table),
file.path(export_dir, paste0("confusion_table_", base_name, ".csv")), row.names = FALSE)
df_cm_stats <- data.frame(t(c(
Accuracy    = as.numeric(cm$overall["Accuracy"]),
Kappa       = as.numeric(cm$overall["Kappa"]),
Precision   = as.numeric(cm$byClass["Pos Pred Value"]),
Recall      = as.numeric(cm$byClass["Sensitivity"]),
Specificity = as.numeric(cm$byClass["Specificity"]),
F1          = f1_from_cm(cm)
)))
write.csv(df_cm_stats, file.path(export_dir, paste0("confusion_stats_", base_name, ".csv")), row.names = FALSE)
roc_df <- data.frame(
threshold = roc_obj$thresholds,
tpr       = roc_obj$sensitivities,
fpr       = 1 - roc_obj$specificities
)
write.csv(roc_df, file.path(export_dir, paste0("roc_points_", base_name, ".csv")), row.names = FALSE)
Xte_dump <- cbind(id = ids, Xte_coord)
write.csv(Xte_dump, file.path(export_dir, paste0("Xte_FAMD_", base_name, ".csv")), row.names = FALSE)
invisible(NULL)
}
out <- list()
## 9) 粗搜 k（CV-ROC）
ctrl5 <- trainControl(method="cv", number=5, classProbs=TRUE, summaryFunction=myROC)
set.seed(123)
fit_coarse <- train(x=X_tr, y=y_tr, method="knn",
trControl=ctrl5, metric="ROC",
tuneGrid=data.frame(k=k_grid_coarse))
k0 <- fit_coarse$bestTune$k
## 10) 细搜 k0±span
k_refine <- sort(unique(pmax(1, k0 + (-k_refine_span:k_refine_span))))
set.seed(123)
fit_base <- train(x=X_tr, y=y_tr, method="knn",
trControl=ctrl5, metric="ROC",
tuneGrid=data.frame(k=k_refine))
## 可选：Accuracy 对比
ctrl_acc <- trainControl(method="cv", number=5)
fit_coarse_acc <- train(x=X_tr, y=y_tr, method="knn",
trControl=ctrl_acc, metric="Accuracy",
tuneGrid=data.frame(k = k_grid_coarse))
with(fit_coarse_acc$results,
plot(k, Accuracy, type="b", pch=16, xlab="k (coarse grid)", ylab="Accuracy (CV)"))
## 基线（不平衡）在内部 test 上的表现
pred_base <- predict(fit_base, newdata=X_te)
prob_base <- predict(fit_base, newdata=X_te, type="prob")[,"Yes"]
roc_base  <- pROC::roc(response=y_te, predictor=prob_base, levels=c("No","Yes"), direction="<")
auc_ext_base <- as.numeric(pROC::auc(roc_base))
cm_base   <- confusionMatrix(pred_base, y_te, positive="Yes")
write_test_bundle(balance_label="No", fit=fit_base, pred=pred_base, prob=prob_base,
cm=cm_base, roc_obj=roc_base,
ids=test_ids, y_true=y_te, Xte_coord=X_te, tag="test")
auc_cv_base <- max(fit_base$results$ROC, na.rm=TRUE)
row_base <- make_row("No", fit_base, cm_base, data_name, ncp_fixed,
auc_cv = auc_cv_base, auc_ext = auc_ext_base)
out[[length(out)+1]] <- .ensure_cols(row_base)
## 11) 各种平衡策略（固定 k_best）
k_best <- fit_base$bestTune$k
one_sampling <- function(samp){
set.seed(123)
ctrl_s <- trainControl(method="cv", number=5,
classProbs=TRUE, summaryFunction=myROC,
sampling=samp)
fit <- train(x=X_tr, y=y_tr, method="knn",
trControl=ctrl_s, metric="ROC",
tuneGrid=data.frame(k=k_best))
pred <- predict(fit, X_te)
prob <- predict(fit, X_te, type="prob")[,"Yes"]
roc_s <- pROC::roc(response=y_te, predictor=prob, levels=c("No","Yes"), direction="<")
auc_ext <- as.numeric(pROC::auc(roc_s))
cm  <- confusionMatrix(pred, y_te, positive="Yes")
write_test_bundle(balance_label=paste0("Si:",samp), fit=fit, pred=pred, prob=prob,
cm=cm, roc_obj=roc_s,
ids=test_ids, y_true=y_te, Xte_coord=X_te, tag="test")
auc_cv <- max(fit$results$ROC, na.rm=TRUE)
.ensure_cols(
make_row(paste0("Si:",samp), fit, cm, data_name, ncp_fixed,
auc_cv = auc_cv, auc_ext = auc_ext)
)
}
for (samp in sampling_vec_fast) out[[length(out)+1]] <- one_sampling(samp)
if (run_smote) out[[length(out)+1]] <- one_sampling("smote")
if (run_rose)  out[[length(out)+1]] <- one_sampling("rose")
res_df <- do.call(rbind, out)
res_df <- .ensure_cols(res_df)
return(res_df)
}
ncp_map <- list(Imputado=19, reducido=8, reducido_plus=10, transformada=28)
res_knn_imputado      <- run_knn(data_imputado,      "Imputado",      res.famd_imp, ncp_map$Imputado)
res_knn_reducida      <- run_knn(data_reducida,      "reducido",      res.famd_red, ncp_map$reducido)
res_knn_reducida_plus <- run_knn(data_reducida_plus, "reducido_plus", res.famd_p,   ncp_map$reducido_plus)
res_knn_transformada  <- run_knn(data_transformada,  "transformada",  res.famd_t,   ncp_map$transformada)
knn_results <- rbind(res_knn_imputado, res_knn_reducida, res_knn_reducida_plus, res_knn_transformada)
knn_results[order(knn_results$DATA, knn_results$Balancea), ]
summ <- do.call(rbind, by(knn_results, knn_results$DATA, function(df){
df[order(-df$AUC_ext, -df$F1.score), ][1, c("DATA","Balancea","k_opt","AUC_cv","AUC_ext","Gap_AUC","F1.score","Recall..S.","Specifici","ncp_used")]
}))
summ
save.image("knn_results.RData")
str(data_imputado)
str(data_reducida)
str(data_reducida_plus)
summ
summ
best_row <- summ[2, ]
best_data_name <- as.character(best_row$DATA)         # e.g., "Imputado"
best_sampling  <- as.character(best_row$Balancea)     # "No" 或 "Si:down"/"Si:up"/"Si:smote"/"Si:rose"
k_best         <- as.integer(best_row$k_opt)
ncp_fixed      <- as.integer(best_row$ncp_used)
# 从你内部对象拿到FAMD用到的变量清单
get_famd_vars_from_internal <- function(best_data_name){
if (best_data_name == "Imputado")      return(colnames(res.famd_imp$call$X))
if (best_data_name == "reducido")      return(colnames(res.famd_red$call$X))
if (best_data_name == "reducido_plus") return(colnames(res.famd_p$call$X))
if (best_data_name == "transformada")  return(colnames(res.famd_t$call$X))
stop("DATA desconocido en summ$DATA: ", best_data_name)
}
famd_vars <- get_famd_vars_from_internal(best_data_name)
setwd("C:/Users/95409/OneDrive/ESTADISTICA/4r/1/MD/Mineria/Entrega_1/MODELOS/KNN")
# 写配置
dir.create("KNN/submission", recursive = TRUE, showWarnings = FALSE)
if (!requireNamespace("yaml", quietly = TRUE)) install.packages("yaml")
yaml::write_yaml(list(
data_name     = best_data_name,
method        = "knn",
k_opt         = k_best,
sampling      = best_sampling,          # "No" 或 "Si:down"/"Si:up"/"Si:smote"/"Si:rose"
ncp           = ncp_fixed,
positive      = "Yes",                  # 统一正类
famd_vars     = famd_vars
), "entrega/artifacts/config.yaml")
yaml::write_yaml(list(
data_name     = best_data_name,
method        = "knn",
k_opt         = k_best,
sampling      = best_sampling,          # "No" 或 "Si:down"/"Si:up"/"Si:smote"/"Si:rose"
ncp           = ncp_fixed,
positive      = "Yes",                  # 统一正类
famd_vars     = famd_vars
), "entrega/submission/config.yaml")
# 写配置
dir.create("KNN/submission", recursive = TRUE, showWarnings = FALSE)
if (!requireNamespace("yaml", quietly = TRUE)) install.packages("yaml")
yaml::write_yaml(list(
data_name     = best_data_name,
method        = "knn",
k_opt         = k_best,
sampling      = best_sampling,          # "No" 或 "Si:down"/"Si:up"/"Si:smote"/"Si:rose"
ncp           = ncp_fixed,
positive      = "Yes",                  # 统一正类
famd_vars     = famd_vars
), "entrega/submission/config.yaml")
if (!requireNamespace("yaml", quietly = TRUE)) install.packages("yaml")
yaml::write_yaml(list(
data_name     = best_data_name,
method        = "knn",
k_opt         = k_best,
sampling      = best_sampling,          # "No" 或 "Si:down"/"Si:up"/"Si:smote"/"Si:rose"
ncp           = ncp_fixed,
positive      = "Yes",                  # 统一正类
famd_vars     = famd_vars
), "KNN/submission/config.yaml")
dir.create("KNN/submission", recursive = TRUE, showWarnings = FALSE)
if (!requireNamespace("yaml", quietly = TRUE)) install.packages("yaml")
yaml::write_yaml(list(
data_name     = best_data_name,
method        = "knn",
k_opt         = k_best,
sampling      = best_sampling,
ncp           = ncp_fixed,
positive      = "Yes",
famd_vars     = famd_vars
), "KNN/submission/config.yaml")
setwd("C:/Users/95409/OneDrive/ESTADISTICA/4r/1/MD/Mineria/Entrega_1/MODELOS/KNN")
View(data)
View(data_imputado)
ncp_map <- list(Imputado=19, reducido=8, reducido_plus=10, transformada=28)
res_knn_imputado      <- run_knn(data_imputado,      "Imputado",      res.famd_imp, ncp_map$Imputado)
res_knn_reducida      <- run_knn(data_reducida,      "reducido",      res.famd_red, ncp_map$reducido)
res_knn_reducida_plus <- run_knn(data_reducida_plus, "reducido_plus", res.famd_p,   ncp_map$reducido_plus)
res_knn_transformada  <- run_knn(data_transformada,  "transformada",  res.famd_t,   ncp_map$transformada)
# === 写出“submission-like” CSV（用内部 test, group=="test"）===
write_internal_submission <- function(
data_df, data_name,
res_famd, ncp_fixed,
k_best,                 # 来自 summ/knn_results 的最佳 k
sampling = NULL,        # NULL / "down" / "up" / "smote" / "rose"
id_col   = NULL,        # 可选：test 主键列名；无则用行名/行号
out_dir  = "submissions",
label_output = FALSE    # TRUE 输出 id,y_pred；默认 FALSE 输出 id,prob_yes
){
dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)
# 1) 划分内部 train/test，并统一 y
d_tr <- subset(data_df, group == "train")
d_te <- subset(data_df, group == "test")
d_tr$Exited <- factor(ifelse(as.character(d_tr$Exited)=="1","Yes","No"),
levels=c("Yes","No"))
# 2) 取 FAMD 变量 & ncp
famd_vars  <- colnames(res_famd$call$X)
ncp_fixed  <- min(ncp_fixed, ncol(res_famd$ind$coord))
# 3) 训练坐标（直接用 FAMD 已有坐标）
if (is.null(rownames(d_tr))) rownames(d_tr) <- make.unique(sprintf("r%05d", 1:nrow(d_tr)))
famd_train_ids <- rownames(res_famd$ind$coord)
keep_ids <- famd_train_ids[famd_train_ids %in% rownames(d_tr)]
X_tr <- as.data.frame(res_famd$ind$coord[keep_ids, 1:ncp_fixed, drop=FALSE])
colnames(X_tr) <- paste0("F", seq_len(ncol(X_tr)))
y_tr <- d_tr[keep_ids, "Exited", drop=TRUE]
# 4) 对齐 test 因子水平 → FAMD 投影
X_te_raw <- d_te[, famd_vars, drop=FALSE]
ref_raw  <- d_tr[keep_ids, famd_vars, drop=FALSE]
for (v in famd_vars) if (is.factor(ref_raw[[v]])) {
X_te_raw[[v]] <- factor(X_te_raw[[v]], levels = levels(ref_raw[[v]]))
}
X_te <- as.data.frame(predict(res_famd, newdata = X_te_raw)$coord[, 1:ncp_fixed, drop=FALSE])
colnames(X_te) <- paste0("F", seq_len(ncol(X_te)))
# 5) 用固定 k 训练 kNN（可选 sampling）
ctrl <- caret::trainControl(method="cv", number=5,
classProbs=TRUE, summaryFunction=twoClassSummary)
if (!is.null(sampling)) ctrl$sampling <- sampling
set.seed(123)
fit <- caret::train(x=X_tr, y=y_tr, method="knn",
trControl=ctrl, metric="ROC",
tuneGrid=data.frame(k=k_best))
# 6) 预测 & 写 CSV
ids <- if (!is.null(id_col) && id_col %in% names(d_te)) d_te[[id_col]] else {
if (!is.null(rownames(d_te))) rownames(d_te) else seq_len(nrow(d_te))
}
bal_tag <- ifelse(is.null(sampling), "NoBal", paste0("Si-", sampling))
if (label_output) {
y_pred <- predict(fit, X_te)
submit <- data.frame(id = ids, y_pred = y_pred, stringsAsFactors = FALSE)
fn <- file.path(out_dir, sprintf("submit_%s__%s__k%d__ncp%d_labels.csv",
data_name, bal_tag, k_best, ncp_fixed))
} else {
prob <- predict(fit, X_te, type="prob")[,"Yes"]
submit <- data.frame(id = ids, prob_yes = prob, stringsAsFactors = FALSE)
fn <- file.path(out_dir, sprintf("submit_%s__%s__k%d__ncp%d.csv",
data_name, bal_tag, k_best, ncp_fixed))
}
write.csv(submit, fn, row.names = FALSE)
message("DONE", fn)
invisible(fn)
}
knn_results <- rbind(res_knn_imputado, res_knn_reducida, res_knn_reducida_plus, res_knn_transformada)
knn_results[order(knn_results$DATA, knn_results$Balancea), ]
summ <- do.call(rbind, by(knn_results, knn_results$DATA, function(df){
df[order(-df$AUC_ext, -df$F1.score), ][1, c("DATA","Balancea","k_opt","AUC_cv","AUC_ext","Gap_AUC","F1.score","Recall..S.","Specifici","ncp_used")]
}))
summ
# 映射：DATA 名 -> 对应的数据框 / FAMD 对象 / ncp
get_bundle <- function(data_name){
switch(data_name,
"Imputado"      = list(df = data_imputado,      famd = res.famd_imp, ncp = ncp_map$Imputado),
"reducido"      = list(df = data_reducida,      famd = res.famd_red, ncp = ncp_map$reducido),
"reducido_plus" = list(df = data_reducida_plus, famd = res.famd_p,   ncp = ncp_map$reducido_plus),
"transformada"  = list(df = data_transformada,  famd = res.famd_t,   ncp = ncp_map$transformada),
stop("DATA desconocido: ", data_name)
)
}
# 对每个 DATA 用 summ 的“冠军”生成一个 CSV（prob_yes 版）
datas <- unique(knn_results$DATA)
for (dn in datas){
best <- subset(knn_results, DATA==dn)
best <- best[order(-best$AUC_ext, -best$F1.score), ][1, ]
k_best   <- as.integer(best$k_opt)
sampling <- as.character(best$Balancea)         # "No" 或 "Si:down"/"Si:up"/"Si:smote"/"Si:rose"
sampling <- if (sampling=="No") NULL else sub("^Si:", "", sampling)
b <- get_bundle(dn)
write_internal_submission(
data_df   = b$df,
data_name = dn,
res_famd  = b$famd,
ncp_fixed = b$ncp,
k_best    = k_best,
sampling  = sampling,      # 与冠军配置一致
id_col    = NULL,          # 如果内部 test 有主键列就在这里填列名
out_dir   = "submissions",
label_output = FALSE       # TRUE 则输出 y_pred
)
}
