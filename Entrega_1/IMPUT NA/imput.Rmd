---
title: "imput na"
author: "Laura Belmonte"
date: "2025-10-12"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r,echo=FALSE, warning=FALSE, message=FALSE}
load("~/Documents/GitHub/Mineria/DATA/data.RData")
library(naniar)
library(ggplot2)
library(visdat)
library(dplyr)
library(tidyr)
library(Hmisc)
```

Los valores faltantes surgen cuando una observación carece de información registrada en una determinada variable. Su correcta gestión es fundamental, ya que eliminarlos indiscriminadamente puede reducir de manera significativa el tamaño del conjunto de datos, mientras que imputarlos de forma inadecuada puede introducir sesgos y distorsionar los resultados del análisis.  

Para abordar este problema existen diversas estrategias. Entre las más comunes se encuentran:  

- **Eliminación** de filas o columnas con un número elevado de valores faltantes.  
- **Imputación simple**, que consiste en reemplazar los valores ausentes con medidas como la media, mediana o moda.  
- **Imputación avanzada**, donde se emplean métodos más sofisticados como K-Nearest Neighbors (KNN) o modelos predictivos para estimar los valores faltantes de manera más precisa.  


# Exploración de los NA

Realizamos un test de Little para comprobar si los NA de nuestros datos son MCAR (aleatorios) o si por el contrario siguen algún patron.

El test de Little se utiliza para evaluar si los datos faltantes en un conjunto de datos siguen el mecanismo **MCAR** (*Missing Completely At Random*).

### Hipótesis

- **Hipótesis nula ($H_0$):**  
  Los valores faltantes son completamente aleatorios (MCAR).  
  Es decir, la probabilidad de que un valor esté ausente no depende de los datos observados   ni de los no observados.  

- **Hipótesis alternativa ($H_1$):**  
  Los valores faltantes no son completamente aleatorios.  
  En este caso, el patrón de datos ausentes depende de los valores observados y/o de los no   observados.  

```{r}
naniar::mcar_test(data)
```

Dado que el pvalor es ampliamente superior a 0.05, aceptamos la hipótesis nula: no hay evidencia estadística para sospechar que los valores faltantes de nuestra base de datos no son fruto de la aleatoriedad.

Vamos a visualizar la distribución de nuestros NA para las diferentes variables.

```{r}
vis_dat(data)
```

Tampoco se observa ningún patrón fuera de los generados para este problema concreto del caso del banco (ID, group, Exited).

Cantidad de NA por variable:
```{r}
gg_miss_var(data) + labs(y = "Look at all the missing ones")
```

Ya habíamos visto que en todas las variables la proporción de NA es del 30%. Esto no pasa para ID, dado que los datos test no tienen valores faltantes ni para group, variable que hemos generado nosotros para indicar si una observación es grupo train/test.

```{r}
vis_miss(data);
```

Con este gràfico estamos recalcando la información conocida por estudios diferentes y por el gràdico anterior


```{r}
pct_miss_case(data)
```

# Imputación de los NA

La imputación básica consiste en reemplazar los valores faltantes por estimaciones simples basadas en los datos disponibles, sin emplear modelos complejos. Entre los métodos más frecuentes se encuentran:

- **Reemplazo por la media o mediana:** posibilidad para las variables numéricas.  
- **Reemplazo por la moda:** aplicable a variables categóricas.  
- **Constante o valor fijo:** se puede asignar un valor específico que tenga sentido según el contexto.  

Estos métodos son fáciles de aplicar y permiten mantener el tamaño original del dataset, aunque no capturan relaciones más complejas entre las variables. Son una primera aproximación al manejo de datos faltantes, y en muchos casos se utilizan como paso previo antes de aplicar técnicas de imputación más avanzadas.

## Imputación por media y mediana

Como hemos comentado anteriormente la imputación de la media o mediana es adecuada para las variables numericas. Aplicaremos estos métodos a dichas variables y comprobaremos si la distribución posterior se ajusta bien a la de los datos con NA.

```{r fig.width=14, fig.height=10}
data_mean <- data %>%
  mutate(across(where(is.numeric),
                ~ Hmisc::impute(., fun = mean),
                .names = "imputed_mean_{.col}"))

data_median <- data %>%
  mutate(across(where(is.numeric),
                ~ Hmisc::impute(., fun = median),
                .names = "imputed_median_{.col}"))

data_all <- data %>%
  bind_cols(
    select(data_mean, starts_with("imputed_mean_")),
    select(data_median, starts_with("imputed_median_"))
  )


df_long_all <- data_all %>%
  select(where(is.numeric)) %>%
  pivot_longer(
    cols = everything(),
    names_to = "VariableCompleta",
    values_to = "Valor"
  ) %>%
  mutate(
    Tipo = case_when(
      grepl("^imputed_mean_", VariableCompleta) ~ "Media",
      grepl("^imputed_median_", VariableCompleta) ~ "Mediana",
      TRUE ~ "Original"
    ),
    Variable = gsub("^(imputed_mean_|imputed_median_)", "", VariableCompleta)
  )
ggplot(df_long_all, aes(x = Valor, fill = Tipo)) +
  geom_density(alpha = 0.3) +
  facet_wrap(~ Variable, scales = "free") +
  theme_minimal() +
  labs(title = "Comparación de imputación por media y mediana",
       fill = "Tipo de dato")
```

Observamos como ni la media ni la mediana parecen métodos fiables para la imputación de ninguna de las numéricas, puesto que la densidad de ninguno de las dos metodologías se ajusta bien a la densidad orignal de los datos sin NA.

## Moda 

```{r,fig.width=14, fig.height=10}
library(dplyr)
library(tidyr)
library(ggplot2)

get_mode <- function(x) {
  ux <- na.omit(unique(x))
  ux[which.max(tabulate(match(x, ux)))]
}

data_mode <- data %>%
  mutate(across(all_of(varCat),
                ~ ifelse(is.na(.), as.character(get_mode(.)), as.character(.)),
                .names = "imputed_mode_{.col}"))

data_all <- data %>%
  select(all_of(varCat)) %>%
  mutate(across(everything(), as.character)) %>%   # <-- forzamos a character para evitar conflictos
  bind_cols(
    data_mode %>%
      select(starts_with("imputed_mode_")) %>%
      mutate(across(everything(), as.character))   # <-- igual aquí
  )

df_long_all <- data_all %>%
  pivot_longer(
    cols = everything(),
    names_to = "VariableCompleta",
    values_to = "Valor"
  ) %>%
  mutate(
    Tipo = case_when(
      grepl("^imputed_mode_", VariableCompleta) ~ "Moda",
      TRUE ~ "Original"
    ),
    Variable = gsub("^(imputed_mode_)", "", VariableCompleta)
  )

ggplot(df_long_all, aes(x = Valor, fill = Tipo)) +
  geom_bar(position = "dodge") +
  facet_wrap(~ Variable, scales = "free") +
  theme_minimal() +
  labs(title = "Comparación de imputación por moda (variables categóricas definidas)",
       fill = "Tipo de dato")

```

La imputación por moda no es el mejor metodo de imputación para las variables categoricas bien porque distorsiona severamente la distribución real de los datos, creando un sesgo excesivo hacia las categorías dominantes y eliminando la variabilidad natural del dataset original.

## Media con variable target

```{r fig.width=14, fig.height=10}
data_imputado <- data

var_numericas <- names(data_imputado)[sapply(data_imputado, is.numeric)]
var_numericas <- var_numericas[var_numericas != "Exited"]

data_imputado <- data_imputado %>%
  group_by(Exited) %>%
  mutate(across(all_of(var_numericas), 
                ~ {
                  media_grupo <- mean(., na.rm = TRUE)
                  ifelse(is.na(.), media_grupo, .)
                })) %>%
  ungroup()

df_original <- data %>%
  select(where(is.numeric)) %>%
  pivot_longer(
    cols = everything(),
    names_to = "Variable",
    values_to = "Valor"
  ) %>%
  mutate(Tipo = "Original")

df_imputado <- data_imputado %>%
  select(where(is.numeric)) %>%
  pivot_longer(
    cols = everything(),
    names_to = "Variable",
    values_to = "Valor"
  ) %>%
  mutate(Tipo = "Imputado")

df_comparacion <- bind_rows(df_original, df_imputado)

ggplot(df_comparacion, aes(x = Valor, fill = Tipo)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~ Variable, scales = "free") +
  theme_minimal() +
  labs(title = "Comparación de distribuciones: Pre vs Post Imputación (Media por Grupo)",
       x = "Valor", 
       y = "Densidad",
       fill = "Tipo de dato") +
  scale_fill_manual(values = c("Original" = "red", "Imputado" = "blue"))
```
Vemos que la imputación de media con una variable target (en este caso exited) tampoco representa una opción fiable de cara a la imputación de datos faltantes, dado que no respeta la densidad original para ninguna de las variables numéricas

## Mi method

El método de imputación múltiple es una técnica estadística avanzada para manejar valores faltantes en un conjunto de datos.

A diferencia de las imputaciones simples, que reemplazan cada valor faltante por un único estimador como la media o la moda, MI genera varios datasets completos donde los valores faltantes son reemplazados por estimaciones diferentes basadas en modelos estadísticos que capturan la incertidumbre de los datos ausentes.

```{r, eval=FALSE}
data_mi<-data
library(dplyr)
library(mi)

data_mi <- data_mi %>%
  mutate(across(where(is.character), as.factor))

colSums(is.na(data_mi))

data_mi <- data_mi %>% select(where(~ any(is.na(.))))

mi_data <- mi(data_mi, seed = 335, m = 3, maxit = 5)

summary(mi_data)

plot(mi_data)
par(ask = FALSE)
```

Por complicaciones técnicas al implementar el método MI, en este trabajo se optó por utilizar el paquete MICE, que permite realizar imputación múltiple de manera más estable y flexible sobre datasets con valores faltantes.

## Multiple chained Equations (MICE)

Para la implementación práctica de la imputación múltiple, se utilizó el paquete MICE.
Este método permite generar múltiples datasets completos mediante modelos estadísticos iterativos, manejando tanto variables numéricas como categóricas de manera eficiente.

En primer caso eliminados aquellas variables categoricas para el analisis

```{r}
library(mice)
library(VIM)
library(caret)

data_mice <- data  

nzv <- nearZeroVar(data_mice, saveMetrics = TRUE)
bad_vars <- rownames(nzv[nzv$zeroVar == TRUE | nzv$nzv == TRUE, ])


one_level <- names(which(sapply(data_mice, function(x) length(unique(na.omit(x)))) <= 1))

remove_vars <- setdiff(unique(c(bad_vars, one_level)), c("ID", "x"))

if (length(remove_vars) > 0) {
  data_mice <- subset(data_mice, select = -remove_vars)
  cat("Variables eliminadas por problemas:", remove_vars, "\n")
}

meth <- make.method(data_mice)

for (v in names(data_mice)) {
  if (is.numeric(data_mice[[v]])) {
    meth[v] <- "pmm"              
  } else if (is.factor(data_mice[[v]])) {
    if (nlevels(data_mice[[v]]) == 2) {
      meth[v] <- "logreg"          
    } else {
      meth[v] <- "cart"     
    }
  }
}

# Inicializar mice
ini <- mice(data_mice, maxit = 0, method = meth)
pred <- ini$predictorMatrix


exclude_vars <- intersect(c("ID", "x"), names(data_mice))
pred[, exclude_vars] <- 0  

imputed_Data <- mice(data_mice, m = 3, maxit = 10, 
                     method = meth, predictorMatrix = pred, seed = 500)

summary(imputed_Data)

```

En la tabla resultado del método MICE se observa con claridad que se han generado 3 datasets imputados, tal como se especificó en el código *(m = 3)*, utilizando el método Predictive Mean Matching *(meth = "pmm")* para las variables numéricas. La PredictorMatrix indica qué variables se emplean como predictores para imputar los valores faltantes de cada variable. 

Al analizar las imputaciones generadas, se observa que todas son consistentes entre sí, lo que indica que el método MICE es estable. En este contexto, lo recomendable no es seleccionar una única imputación, sino combinar los resultados de todas las imputaciones mediante pooling, obteniendo así estimaciones más robustas y precisas.

```{r}

VIM::aggr(data_mice, col=c('navyblue','yellow'),
          numbers=TRUE, sortVars=TRUE,
          labels=names(data_mice), cex.axis=.7,
          gap=3, ylab=c("Missing data","Pattern"))

# Stripplots para variables numéricas
stripplot(imputed_Data, CreditScore, pch = 19, xlab = "Imputation number")
stripplot(imputed_Data, NumOfProducts, pch = 19, xlab = "Imputation number")

```

Como hemos comentado anteriormente en el apartado de *exploración de NA* todas las variables tienen exactamente una representación del 30% de valores faltantes. En el panel derecho revela mediante la ayuda de un heatmap el patrón de distribución de estos valores faltantes a lo largo de las observaciones (filas), donde amarillo representa datos presentes y azul oscuro datos ausentes, mostrando que los missings no siguen un patrón completamente aleatorio como se habia supuesto con el *test de little* sino que tienden a agruparse en ciertas regiones del dataset.

```{r}
library(mice)
library(ggplot2)

mice::densityplot(imputed_Data)

mice::densityplot(imputed_Data, ~CreditScore, main = "Densidad de CreditScore imputado")

mice::densityplot(imputed_Data, ~CreditScore + NumOfProducts, 
                  main = "Densidades de variables imputadas")


completeData <- mice::complete(imputed_Data, 1)

# Convertir a formato largo para ggplot
library(tidyr)
data_long <- pivot_longer(completeData, cols = names(completeData), names_to = "Variable", values_to = "Valor")

ggplot(data_long, aes(x = Valor, color = Variable, fill = Variable)) +
  geom_density(alpha = 0.3) +
  facet_wrap(~Variable, scales = "free") +
  theme_minimal() +
  labs(title = "Densidades de variables imputadas (una imputación)")
```


```{r}
m <- imputed_Data$m 

imp_number <- sample(1:m, 1)

completeData <- mice::complete(imputed_Data, imp_number)
summary(completeData)
```



