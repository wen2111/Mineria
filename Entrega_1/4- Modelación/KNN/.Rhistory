cols_to_drop <- intersect(id_cols, names(data))
if (length(cols_to_drop) > 0) data <- subset(data, select = setdiff(names(data), cols_to_drop))
# 3) Check target y limpieza de NA en target
if (!target %in% names(data)) stop("No se encuentra la columna target: ", target)
data <- data[!is.na(data[[target]]), , drop = FALSE]
# 4) Pasar character -> factor (coherencia con FAMD)
char_cols <- names(data)[vapply(data, is.character, logical(1))]
for (nm in char_cols) data[[nm]] <- factor(data[[nm]])
# 5) Split interno
n <- nrow(data)
idx_train <- sample.int(n, size = floor(train_prop * n))
df_train  <- data[idx_train, , drop = FALSE]
df_test   <- data[-idx_train, , drop = FALSE]
# 6) X/y
ytr <- df_train[[target]]; if (!is.factor(ytr)) ytr <- factor(ytr)
yte <- df_test[[target]]; if (!is.factor(yte)) yte <- factor(yte)
x_train <- df_train[, setdiff(names(df_train), target), drop = FALSE]
x_test  <- df_test[,  setdiff(names(df_test),  target), drop = FALSE]
# 7) Alinear niveles factor en test
for (nm in names(x_train)) {
if (is.factor(x_train[[nm]])) {
x_test[[nm]] <- factor(x_test[[nm]], levels = levels(x_train[[nm]]))
}
}
# 8) Ajustar FAMD SOLO con train (ncp = Inf para obtener todas y recortar luego)
famd_fit <- FAMD(x_train, ncp = Inf, graph = FALSE)
# 9) Coords de train y proyección de test
coord_train_full <- famd_fit$ind$coord
coord_test_full  <- predict(famd_fit, newdata = x_test)$coord
# 10) Recorte a ncp fijo según mapa (con tope de columnas disponibles)
max_dim_train <- ncol(coord_train_full)
max_dim_test  <- ncol(coord_test_full)
ncp_use <- min(ncp_fixed, max_dim_train, max_dim_test)
if (ncp_fixed > max_dim_train) {
warning(sprintf("ncp_map[%s]=%d > dim disponibles (%d). Se usará %d.",
dataset_key, ncp_fixed, max_dim_train, ncp_use))
}
coord_train <- coord_train_full[, seq_len(ncp_use), drop = FALSE]
coord_test  <- coord_test_full[,  seq_len(ncp_use),  drop = FALSE]
# 11) Guardar a disco
train_file <- file.path(save_dir, paste0("famd_coords_", dataset_key, "_train.rds"))
test_file  <- file.path(save_dir, paste0("famd_coords_", dataset_key, "_test.rds"))
saveRDS(coord_train, train_file)
saveRDS(coord_test,  test_file)
# 12) Salida
list(
Xtr = coord_train,
Xte = coord_test,
ytr = ytr,
yte = yte,
ncp_used = ncp_use,
famd_model = famd_fit,
saved_files = list(train=train_file, test=test_file)
)
}
# Imputado
res_imp <- prep_famd_fixed_ncp(
data = data_imputado,
dataset_key = "Imputado",
ncp_map = ncp_map,
target = "Exited",
id_cols = c("group","ID","ClienteID"),
train_prop = 0.7,
seed = 123,
filter_official_train = TRUE,  # primero group=='train'
save_dir = "."                 # guarda .rds en el directorio actual
)
# Reducido
res_red <- prep_famd_fixed_ncp(
data = data_reducida, dataset_key = "reducido",
ncp_map = ncp_map, target = "Exited",
id_cols = c("group","ID","ClienteID"),
filter_official_train = FALSE  # si este objeto no trae 'group', pon FALSE
)
# Reducido plus
res_rp <- prep_famd_fixed_ncp(
data = data_reducida_plus, dataset_key = "reducido_plus",
ncp_map = ncp_map, target = "Exited",
id_cols = c("group","ID","ClienteID"),
filter_official_train = TRUE
)
# Transformada
res_t <- prep_famd_fixed_ncp(
data = data_transformada, dataset_key = "transformada",
ncp_map = ncp_map, target = "Exited",
id_cols = c("group","ID","ClienteID"),
filter_official_train = TRUE
)
res_t
res_rp
res_red
res_imp
# Los archivos creados:
# ./famd_coords_Imputado_train.rds
# ./famd_coords_Imputado_test.rds
# (idem para reducido, reducido_plus, transformada)
save.image("famd_auto_workspace.RData")
# Imputado
res_imp <- prep_famd_fixed_ncp(
data = data_imputado,
dataset_key = "Imputado",
ncp_map = ncp_map,
target = "Exited",
id_cols = c("group","ID","ClienteID"),
train_prop = 0.7,
seed = 123,
filter_official_train = TRUE,  # primero group=='train'
save_dir = "."                 # guarda .rds en el directorio actual
)
# Reducido
res_red <- prep_famd_fixed_ncp(
data = data_reducida, dataset_key = "reducido",
ncp_map = ncp_map, target = "Exited",
id_cols = c("group","ID","ClienteID"),
filter_official_train = FALSE  # si este objeto no trae 'group', pon FALSE
)
# Reducido plus
res_rp <- prep_famd_fixed_ncp(
data = data_reducida_plus, dataset_key = "reducido_plus",
ncp_map = ncp_map, target = "Exited",
id_cols = c("group","ID","ClienteID"),
filter_official_train = TRUE
)
# Transformada
res_t <- prep_famd_fixed_ncp(
data = data_transformada, dataset_key = "transformada",
ncp_map = ncp_map, target = "Exited",
id_cols = c("group","ID","ClienteID"),
filter_official_train = TRUE
)
# Los archivos creados:
# ./famd_coords_Imputado_train.rds
# ./famd_coords_Imputado_test.rds
# (idem para reducido, reducido_plus, transformada)
save.image("famd_auto_workspace.RData")
setwd("C:/Users/95409/OneDrive/ESTADISTICA/4r/1/MD/Mineria/Entrega_1/famd")
# Los archivos creados:
# ./famd_coords_Imputado_train.rds
# ./famd_coords_Imputado_test.rds
# (idem para reducido, reducido_plus, transformada)
save.image("famd_auto_workspace.RData")
res_rp
View(res_knn_imputado)
View(res_rp)
View(res_red)
View(res_rp)
View(res_t)
View(res_imp)
res_red[["Xtr"]]
library(caret)
library(pROC)
library(ROSE)
set.seed(123)
f1_from_cm <- function(cm){
p <- as.numeric(cm$byClass["Pos Pred Value"])
r <- as.numeric(cm$byClass["Sensitivity"])
if (is.na(p) || is.na(r) || (p+r)==0) return(NA_real_)
2*p*r/(p+r)
}
myROC <- function(data, lev=NULL, model=NULL){
twoClassSummary(data, lev = c("Yes","No"))
}
# 固定维度映射（直接在文件顶部定义一次）
ncp_map <- list(Imputado=19, reducido=8, reducido_plus=10, transformada=28)
# res_obj: res_imp / res_red / res_rp / res_t
run_knn_from_famd <- function(
res_obj, data_name,
sampling_vec = c("none","down","up","smote","rose"),
k_grid_coarse = seq(1, 11, 2),
k_refine_span = 2
){
## 1) 准备数据 + 按 ncp_map 裁剪维度（内联，不用额外函数）
Xtr_full <- as.data.frame(res_obj$Xtr)
Xte_full <- as.data.frame(res_obj$Xte)
if (data_name %in% names(ncp_map)) {
ncp_fixed <- ncp_map[[data_name]]
p <- min(ncp_fixed, ncol(Xtr_full), ncol(Xte_full))
if (p < ncp_fixed) warning(sprintf("%s: 请求 ncp=%d 超过可用维度，已使用 %d。", data_name, ncp_fixed, p))
Xtr <- Xtr_full[, seq_len(p), drop = FALSE]
Xte <- Xte_full[, seq_len(p), drop = FALSE]
} else {
# 若 data_name 不在 ncp_map，就不裁剪
Xtr <- Xtr_full
Xte <- Xte_full
}
ytr <- factor(ifelse(as.character(res_obj$ytr) == "1", "Yes", "No"),
levels = c("Yes","No"))
yte <- factor(ifelse(as.character(res_obj$yte) == "1", "Yes", "No"),
levels = c("Yes","No"))
colnames(Xtr) <- paste0("F", seq_len(ncol(Xtr)))
colnames(Xte) <- paste0("F", seq_len(ncol(Xte)))
## 2) 先在不采样上确定 k_best（以 ROC 为主）
ctrl_cv_roc <- trainControl(method="cv", number=5, classProbs=TRUE, summaryFunction=myROC)
fit_coarse <- train(x=Xtr, y=ytr, method="knn",
trControl=ctrl_cv_roc, metric="ROC",
tuneGrid=data.frame(k=k_grid_coarse))
k0 <- fit_coarse$bestTune$k
k_refine <- sort(unique(pmax(1, k0 + (-k_refine_span:k_refine_span))))
fit_base <- train(x=Xtr, y=ytr, method="knn",
trControl=ctrl_cv_roc, metric="ROC",
tuneGrid=data.frame(k=k_refine))
k_best <- fit_base$bestTune$k
## 3) 评估函数：给定 sampling，产出 train/test 两套指标
eval_one <- function(samp){
ctrl <- if (samp=="none") {
trainControl(method="cv", number=5, classProbs=TRUE, summaryFunction=myROC)
} else {
trainControl(method="cv", number=5, classProbs=TRUE, summaryFunction=myROC, sampling=samp)
}
fit <- train(x=Xtr, y=ytr, method="knn",
trControl=ctrl, metric="ROC",
tuneGrid=data.frame(k=k_best))
# --- on TRAIN ---
pred_tr <- predict(fit, newdata=Xtr)
prob_tr <- predict(fit, newdata=Xtr, type="prob")[,"Yes"]
roc_tr  <- pROC::roc(response=ytr, predictor=prob_tr, levels=c("No","Yes"), direction="<")
auc_tr  <- as.numeric(pROC::auc(roc_tr))
cm_tr   <- confusionMatrix(pred_tr, ytr, positive="Yes")
row_tr <- data.frame(
DATA=data_name, Split="train", Sampling=samp, Method="KNN",
ncp_used = ncol(Xtr), k_best = k_best,
ROC_CV = max(fit$results$ROC, na.rm=TRUE),
Sens_CV = fit$results$Sens[fit$results$k==k_best],
Spec_CV = fit$results$Spec[fit$results$k==k_best],
Accuracy = as.numeric(cm_tr$overall["Accuracy"]),
Precision = as.numeric(cm_tr$byClass["Pos Pred Value"]),
Recall = as.numeric(cm_tr$byClass["Sensitivity"]),
Specificity = as.numeric(cm_tr$byClass["Specificity"]),
F1 = f1_from_cm(cm_tr),
AUC = auc_tr,
stringsAsFactors = FALSE
)
# --- on TEST ---
pred_te <- predict(fit, newdata=Xte)
prob_te <- predict(fit, newdata=Xte, type="prob")[,"Yes"]
roc_te  <- pROC::roc(response=yte, predictor=prob_te, levels=c("No","Yes"), direction="<")
auc_te  <- as.numeric(pROC::auc(roc_te))
cm_te   <- confusionMatrix(pred_te, yte, positive="Yes")
row_te <- data.frame(
DATA=data_name, Split="test", Sampling=samp, Method="KNN",
ncp_used = ncol(Xtr), k_best = k_best,
ROC_CV = max(fit$results$ROC, na.rm=TRUE),
Sens_CV = fit$results$Sens[fit$results$k==k_best],
Spec_CV = fit$results$Spec[fit$results$k==k_best],
Accuracy = as.numeric(cm_te$overall["Accuracy"]),
Precision = as.numeric(cm_te$byClass["Pos Pred Value"]),
Recall = as.numeric(cm_te$byClass["Sensitivity"]),
Specificity = as.numeric(cm_te$byClass["Specificity"]),
F1 = f1_from_cm(cm_te),
AUC = auc_te,
stringsAsFactors = FALSE
)
rbind(row_tr, row_te)
}
sampling_vec <- unique(sampling_vec)
res <- do.call(rbind, lapply(sampling_vec, eval_one))
rownames(res) <- NULL
res
}
metrics_imp <- run_knn_from_famd(res_imp, "Imputado",
sampling_vec=c("none","down","up","smote","rose"))
metrics_imp
metrics_imp
metrics_imp <- run_knn_from_famd(res_imp, "Imputado", sampling_vec=c("none","down","up","smote","rose"))
metrics_red <- run_knn_from_famd(res_red, "Reducido", sampling_vec=c("none","down","up","smote","rose"))
metrics_rp  <- run_knn_from_famd(res_rp, "Reducido_plus", sampling_vec=c("none","down","up","smote","rose"))
metrics_t   <- run_knn_from_famd(res_t, "Transformada", sampling_vec=c("none","down","up","smote","rose"))
save.image("knn_famd.RData")
View(res_imp)
save.image("knn_con_famd.RData")
setwd("C:/Users/95409/OneDrive/ESTADISTICA/4r/1/MD/Mineria/Entrega_1/4- Modelación/KNN")
metrics_imp <- run_knn_from_famd(res_imp, "Imputado", sampling_vec=c("none","down","up","smote","rose"))
metrics_red <- run_knn_from_famd(res_red, "Reducido", sampling_vec=c("none","down","up","smote","rose"))
metrics_rp  <- run_knn_from_famd(res_rp, "Reducido_plus", sampling_vec=c("none","down","up","smote","rose"))
metrics_t   <- run_knn_from_famd(res_t, "Transformada", sampling_vec=c("none","down","up","smote","rose"))
save.image("knn_con_famd.RData")
library(ROSE)
set.seed(123)
load("famd_auto.RData") # res_imp, res_red, res_rp, res_t
f1_from_cm <- function(cm){
p <- as.numeric(cm$byClass["Pos Pred Value"])
r <- as.numeric(cm$byClass["Sensitivity"])
if (is.na(p) || is.na(r) || (p+r)==0) return(NA_real_)
2*p*r/(p+r)
}
myROC <- function(data, lev=NULL, model=NULL){
twoClassSummary(data, lev = c("Yes","No"))
}
ncp_map <- list(Imputado=19, reducido=8, reducido_plus=10, transformada=28)
# res_obj: res_imp / res_red / res_rp / res_t
run_knn_from_famd <- function(
res_obj, data_name,
sampling_vec = c("none","down","up","smote","rose"),
k_grid_coarse = seq(5,7,9),
k_refine_span = 0
){
Xtr_full <- as.data.frame(res_obj$Xtr)
Xte_full <- as.data.frame(res_obj$Xte)
if (data_name %in% names(ncp_map)) {
ncp_fixed <- ncp_map[[data_name]]
p <- min(ncp_fixed, ncol(Xtr_full), ncol(Xte_full))
if (p < ncp_fixed) warning(sprintf("", data_name, ncp_fixed, p))
Xtr <- Xtr_full[, seq_len(p), drop = FALSE]
Xte <- Xte_full[, seq_len(p), drop = FALSE]
} else {
Xtr <- Xtr_full
Xte <- Xte_full
}
ytr <- factor(ifelse(as.character(res_obj$ytr) == "1", "Yes", "No"),
levels = c("Yes","No"))
yte <- factor(ifelse(as.character(res_obj$yte) == "1", "Yes", "No"),
levels = c("Yes","No"))
colnames(Xtr) <- paste0("F", seq_len(ncol(Xtr)))
colnames(Xte) <- paste0("F", seq_len(ncol(Xte)))
## 2) k_best busqueda por 2 etapas
ctrl_cv_roc <- trainControl(method="cv", number=5, classProbs=TRUE, summaryFunction=myROC)
fit_coarse <- train(x=Xtr, y=ytr, method="knn",
trControl=ctrl_cv_roc, metric="ROC",
tuneGrid=data.frame(k=k_grid_coarse))
k0 <- fit_coarse$bestTune$k
k_refine <- sort(unique(pmax(1, k0 + (-k_refine_span:k_refine_span))))
fit_base <- train(x=Xtr, y=ytr, method="knn",
trControl=ctrl_cv_roc, metric="ROC",
tuneGrid=data.frame(k=k_refine))
k_best <- fit_base$bestTune$k
## 3) train & eval con k_best
eval_one <- function(samp){
ctrl <- if (samp=="none") {
trainControl(method="cv", number=5, classProbs=TRUE, summaryFunction=myROC)
} else {
trainControl(method="cv", number=5, classProbs=TRUE, summaryFunction=myROC, sampling=samp)
}
fit <- train(x=Xtr, y=ytr, method="knn",
trControl=ctrl, metric="ROC",
tuneGrid=data.frame(k=k_best))
# Train
pred_tr <- predict(fit, newdata=Xtr)
prob_tr <- predict(fit, newdata=Xtr, type="prob")[,"Yes"]
roc_tr  <- pROC::roc(response=ytr, predictor=prob_tr, levels=c("No","Yes"), direction="<")
auc_tr  <- as.numeric(pROC::auc(roc_tr))
cm_tr   <- confusionMatrix(pred_tr, ytr, positive="Yes")
row_tr <- data.frame(
DATA=data_name, Split="train", Sampling=samp, Method="KNN",
ncp_used = ncol(Xtr), k_best = k_best,
ROC_CV = max(fit$results$ROC, na.rm=TRUE),
Sens_CV = fit$results$Sens[fit$results$k==k_best],
Spec_CV = fit$results$Spec[fit$results$k==k_best],
Accuracy = as.numeric(cm_tr$overall["Accuracy"]),
Precision = as.numeric(cm_tr$byClass["Pos Pred Value"]),
Recall = as.numeric(cm_tr$byClass["Sensitivity"]),
Specificity = as.numeric(cm_tr$byClass["Specificity"]),
F1 = f1_from_cm(cm_tr),
AUC = auc_tr,
stringsAsFactors = FALSE
)
# TEST
pred_te <- predict(fit, newdata=Xte)
prob_te <- predict(fit, newdata=Xte, type="prob")[,"Yes"]
roc_te  <- pROC::roc(response=yte, predictor=prob_te, levels=c("No","Yes"), direction="<")
auc_te  <- as.numeric(pROC::auc(roc_te))
cm_te   <- confusionMatrix(pred_te, yte, positive="Yes")
row_te <- data.frame(
DATA=data_name, Split="test", Sampling=samp, Method="KNN",
ncp_used = ncol(Xtr), k_best = k_best,
ROC_CV = max(fit$results$ROC, na.rm=TRUE),
Sens_CV = fit$results$Sens[fit$results$k==k_best],
Spec_CV = fit$results$Spec[fit$results$k==k_best],
Accuracy = as.numeric(cm_te$overall["Accuracy"]),
Precision = as.numeric(cm_te$byClass["Pos Pred Value"]),
Recall = as.numeric(cm_te$byClass["Sensitivity"]),
Specificity = as.numeric(cm_te$byClass["Specificity"]),
F1 = f1_from_cm(cm_te),
AUC = auc_te,
stringsAsFactors = FALSE
)
rbind(row_tr, row_te)
}
sampling_vec <- unique(sampling_vec)
res <- do.call(rbind, lapply(sampling_vec, eval_one))
rownames(res) <- NULL
res
}
metrics_imp <- run_knn_from_famd(res_imp, "Imputado", sampling_vec=c("none","down","up","smote","rose"))
metrics_red <- run_knn_from_famd(res_red, "Reducido", sampling_vec=c("none","down","up","smote","rose"))
metrics_rp  <- run_knn_from_famd(res_rp, "Reducido_plus", sampling_vec=c("none","down","up","smote","rose"))
metrics_t   <- run_knn_from_famd(res_t, "Transformada", sampling_vec=c("none","down","up","smote","rose"))
save.image("knn_con_famd.RData")
save.image("knn_con_famd.RData")
metrics_imp
metrics_red
metrics_rp
metrics_t
metrics_rp
metrics_t
f1_from_cm <- function(cm){
p <- as.numeric(cm$byClass["Pos Pred Value"])
r <- as.numeric(cm$byClass["Sensitivity"])
if (is.na(p) || is.na(r) || (p+r)==0) return(NA_real_)
2*p*r/(p+r)
}
myROC <- function(data, lev=NULL, model=NULL){
twoClassSummary(data, lev = c("Yes","No"))
}
ncp_map <- list(Imputado=19, reducido=8, reducido_plus=10, transformada=28)
# res_obj: res_imp / res_red / res_rp / res_t
run_knn_from_famd <- function(
res_obj, data_name,
sampling_vec = c("none","down","up","smote","rose"),
k_grid_coarse = c(5,7,9),
k_refine_span = 0
){
Xtr_full <- as.data.frame(res_obj$Xtr)
Xte_full <- as.data.frame(res_obj$Xte)
if (data_name %in% names(ncp_map)) {
ncp_fixed <- ncp_map[[data_name]]
p <- min(ncp_fixed, ncol(Xtr_full), ncol(Xte_full))
if (p < ncp_fixed) warning(sprintf("", data_name, ncp_fixed, p))
Xtr <- Xtr_full[, seq_len(p), drop = FALSE]
Xte <- Xte_full[, seq_len(p), drop = FALSE]
} else {
Xtr <- Xtr_full
Xte <- Xte_full
}
ytr <- factor(ifelse(as.character(res_obj$ytr) == "1", "Yes", "No"),
levels = c("Yes","No"))
yte <- factor(ifelse(as.character(res_obj$yte) == "1", "Yes", "No"),
levels = c("Yes","No"))
colnames(Xtr) <- paste0("F", seq_len(ncol(Xtr)))
colnames(Xte) <- paste0("F", seq_len(ncol(Xte)))
## 2) k_best busqueda por 2 etapas
ctrl_cv_roc <- trainControl(method="cv", number=5, classProbs=TRUE, summaryFunction=myROC)
fit_coarse <- train(x=Xtr, y=ytr, method="knn",
trControl=ctrl_cv_roc, metric="ROC",
tuneGrid=data.frame(k=k_grid_coarse))
k0 <- fit_coarse$bestTune$k
k_refine <- sort(unique(pmax(1, k0 + (-k_refine_span:k_refine_span))))
fit_base <- train(x=Xtr, y=ytr, method="knn",
trControl=ctrl_cv_roc, metric="ROC",
tuneGrid=data.frame(k=k_refine))
k_best <- fit_base$bestTune$k
## 3) train & eval con k_best
eval_one <- function(samp){
ctrl <- if (samp=="none") {
trainControl(method="cv", number=5, classProbs=TRUE, summaryFunction=myROC)
} else {
trainControl(method="cv", number=5, classProbs=TRUE, summaryFunction=myROC, sampling=samp)
}
fit <- train(x=Xtr, y=ytr, method="knn",
trControl=ctrl, metric="ROC",
tuneGrid=data.frame(k=k_best))
# Train
pred_tr <- predict(fit, newdata=Xtr)
prob_tr <- predict(fit, newdata=Xtr, type="prob")[,"Yes"]
roc_tr  <- pROC::roc(response=ytr, predictor=prob_tr, levels=c("No","Yes"), direction="<")
auc_tr  <- as.numeric(pROC::auc(roc_tr))
cm_tr   <- confusionMatrix(pred_tr, ytr, positive="Yes")
row_tr <- data.frame(
DATA=data_name, Split="train", Sampling=samp, Method="KNN",
ncp_used = ncol(Xtr), k_best = k_best,
ROC_CV = max(fit$results$ROC, na.rm=TRUE),
Sens_CV = fit$results$Sens[fit$results$k==k_best],
Spec_CV = fit$results$Spec[fit$results$k==k_best],
Accuracy = as.numeric(cm_tr$overall["Accuracy"]),
Precision = as.numeric(cm_tr$byClass["Pos Pred Value"]),
Recall = as.numeric(cm_tr$byClass["Sensitivity"]),
Specificity = as.numeric(cm_tr$byClass["Specificity"]),
F1 = f1_from_cm(cm_tr),
AUC = auc_tr,
stringsAsFactors = FALSE
)
# TEST
pred_te <- predict(fit, newdata=Xte)
prob_te <- predict(fit, newdata=Xte, type="prob")[,"Yes"]
roc_te  <- pROC::roc(response=yte, predictor=prob_te, levels=c("No","Yes"), direction="<")
auc_te  <- as.numeric(pROC::auc(roc_te))
cm_te   <- confusionMatrix(pred_te, yte, positive="Yes")
row_te <- data.frame(
DATA=data_name, Split="test", Sampling=samp, Method="KNN",
ncp_used = ncol(Xtr), k_best = k_best,
ROC_CV = max(fit$results$ROC, na.rm=TRUE),
Sens_CV = fit$results$Sens[fit$results$k==k_best],
Spec_CV = fit$results$Spec[fit$results$k==k_best],
Accuracy = as.numeric(cm_te$overall["Accuracy"]),
Precision = as.numeric(cm_te$byClass["Pos Pred Value"]),
Recall = as.numeric(cm_te$byClass["Sensitivity"]),
Specificity = as.numeric(cm_te$byClass["Specificity"]),
F1 = f1_from_cm(cm_te),
AUC = auc_te,
stringsAsFactors = FALSE
)
rbind(row_tr, row_te)
}
sampling_vec <- unique(sampling_vec)
res <- do.call(rbind, lapply(sampling_vec, eval_one))
rownames(res) <- NULL
res
}
metrics_imp <- run_knn_from_famd(res_imp, "Imputado", sampling_vec=c("none","down","up","smote","rose"))
metrics_red <- run_knn_from_famd(res_red, "Reducido", sampling_vec=c("none","down","up","smote","rose"))
metrics_rp  <- run_knn_from_famd(res_rp, "Reducido_plus", sampling_vec=c("none","down","up","smote","rose"))
metrics_t   <- run_knn_from_famd(res_t, "Transformada", sampling_vec=c("none","down","up","smote","rose"))
save.image("knn_con_famd.RData")
metrics_t   <- run_knn_from_famd(res_t, "Transformada", sampling_vec=c("none","down","up","smote","rose"))
metrics_rp  <- run_knn_from_famd(res_rp, "Reducido_plus", sampling_vec=c("none","down","up","smote","rose"))
metrics_red <- run_knn_from_famd(res_red, "Reducido", sampling_vec=c("none","down","up","smote","rose"))
metrics_imp <- run_knn_from_famd(res_imp, "Imputado", sampling_vec=c("none","down","up","smote","rose"))
save.image("knn_con_famd.RData")
metrics_imp
metrics_red
metrics_rp
metrics_t
save.image("knn_con_famd.RData")
