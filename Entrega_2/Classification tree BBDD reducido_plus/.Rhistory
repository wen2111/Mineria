sqet2<-100.118
k<-3
T<-2010-1970
T
t<-T+1
denom<-(SQET-(sqet2+sqet1))/3
num<-(sqet1+sqet2)/(t-2*k)
denom/num
num<-3*0.66-2*0.125
denom<-0.0011+0.0012-2*0.0002
den<-sqrt(denom)
num<-num-3
num/den
numerador<-0.66*3-0.125*2-3
denom<-4*0.0011+9*0.0012-12*0.0002
den<-sqrt(denom)
numerador/den
0.5219
1-0.5219
0.3528+0.2591
1-0.2456615
0.2456615/(0.6089679 - 0.2456615)
(0.2456615^2)/(0.6089679(0.6089679 - 0.2456615))
(0.2456615^2)/(0.6089679*(0.6089679 - 0.2456615))
0.6761827/0.2456615
0.2727764/0.2456615
1-0.4077
data <- data.frame(
A = rnorm(100),
B = rnorm(100),
C = rnorm(100),
D = rnorm(100)
)
data
dim(data)
R <- cor(data)
dim(R)
set.seed(123)
data <- data.frame(
A = rnorm(100),
B = rnorm(100),
C = rnorm(100),
D = rnorm(100)
)
R <- cor(data)
View(R)
P<-solve(R)
View(P)
p <- ncol(P)
partial_cor <- matrix(NA, nrow = p, ncol = p)
colnames(partial_cor) <- rownames(partial_cor) <- colnames(data)
View(partial_cor)
round(partial_cor, 3)
# Calcular correlaciones parciales
for (i in 1:p) {
for (j in 1:p) {
if (i == j) {
partial_cor[i, j] <- 1
} else {
partial_cor[i, j] <- -P[i, j] / sqrt(P[i, i] * P[j, j])
}
}
}
round(partial_cor, 3)
set.seed(1)
n <- 100
n <- 100
p <- 5
X <- matrix(rnorm(n * p), n, p)
colnames(X) <- paste0("V", 1:p)
# Pearson entre V1 y V2
cor(X[,1], X[,2])
pcor(X)$estimate
library(ppcor)
pcor(X)$estimate
pcor.test(X[,1],X[,2],X[,3:5])
pcor(X[,1],X[,2],X[,3:5])
install.packages('epibasix')
library(epibasix)
tabla <- matrix(c(7,125,8,860),2,2,byrow=T) # Tabla 2
results <- epi2x2(tabla)
attach(results)
x
X
View(tabla)
View(results)
#CIL=Confidence Interval Lower; CIU=Confidence Interval Upper
# rdCo=Risk Difference
# Estimación puntual e IC para la DR
rdCo;rdCo.CIL;rdCo.CIU
# Estimación puntual e IC para el RP
RP;RP.CIL;RP.CIU
# Estimación puntual e IC para el RP
RP;RP.CIL;RP.CIU
# Estimación puntual e IC para el RP
RP;RP.CIL;RP.CIU
# Estimación puntual e IC para el RP
RP;RP.CIL;RP.CIU
# Estimación puntual e IC para el OR
OR;OR.CIL;OR.CIU
detach(results)
# Estimación puntual e IC para el RP
RP;RP.CIL;RP.CIU
library(epibasix)
tabla <- matrix(c(7,125,8,860),2,2,byrow=T) # Tabla 2
results <- epi2x2(tabla)
attach(results) #Et dona tots els resultats posibles
#CIL=Confidence Interval Lower; CIU=Confidence Interval Upper
# rdCo=Risk Difference
# Estimación puntual e IC para la DR
rdCo;rdCo.CIL;rdCo.CIU
# Estimación puntual e IC para el RP
RP;RP.CIL;RP.CIU
View(results)
# Estimación puntual e IC para el RP
RR;RR.CIL;RR.CIU
knitr::opts_chunk$set(echo = TRUE)
load("~/Documents/GitHub/Mineria/DATA/data.RData")
library(naniar)
library(ggplot2)
library(visdat)
library(dplyr)
library(tidyr)
library(Hmisc)
library(dplyr)
library(tidyr)
library(ggplot2)
get_mode <- function(x) {
ux <- na.omit(unique(x))
ux[which.max(tabulate(match(x, ux)))]
}
data_mode <- data %>%
mutate(across(all_of(varCat),
~ ifelse(is.na(.), as.character(get_mode(.)), as.character(.)),
.names = "imputed_mode_{.col}"))
data_all <- data %>%
select(all_of(varCat)) %>%
mutate(across(everything(), as.character)) %>%   # <-- forzamos a character para evitar conflictos
bind_cols(
data_mode %>%
select(starts_with("imputed_mode_")) %>%
mutate(across(everything(), as.character))   # <-- igual aquí
)
df_long_all <- data_all %>%
pivot_longer(
cols = everything(),
names_to = "VariableCompleta",
values_to = "Valor"
) %>%
mutate(
Tipo = case_when(
grepl("^imputed_mode_", VariableCompleta) ~ "Moda",
TRUE ~ "Original"
),
Variable = gsub("^(imputed_mode_)", "", VariableCompleta)
)
ggplot(df_long_all, aes(x = Valor, fill = Tipo)) +
geom_bar(position = "dodge") +
facet_wrap(~ Variable, scales = "free") +
theme_minimal() +
labs(title = "Comparación de imputación por moda (variables categóricas definidas)",
fill = "Tipo de dato")
library(mice)
library(VIM)
# Usar todos los datos, incluidos numéricos y categóricos
data_mice <- data
# Visualizar NA’s
VIM::aggr(data_mice, col=c('navyblue','yellow'),
numbers=TRUE, sortVars=TRUE,
labels=names(data_mice), cex.axis=.7,
gap=3, ylab=c("Missing data","Pattern"))
# Definir métodos según tipo de variable
meth <- make.method(data_mice)
for (v in names(data_mice)) {
if (is.numeric(data_mice[[v]])) {
meth[v] <- "pmm"              # numéricas
} else if (is.factor(data_mice[[v]])) {
if (nlevels(data_mice[[v]]) == 2) {
meth[v] <- "logreg"         # binarias
} else {
meth[v] <- "polyreg"        # categóricas con más de 2 niveles
}
}
}
# Imputación mixta
imputed_Data <- mice(data_mice, m = 5, maxit = 50, method = meth, seed = 500)
library(mice)
library(VIM)
library(caret)
data_mice <- data
# ===============================
# 2. Quitar variables problemáticas
# ===============================
# Variables con varianza cero o casi cero
nzv <- nearZeroVar(data_mice, saveMetrics = TRUE)
bad_vars <- rownames(nzv[nzv$zeroVar == TRUE | nzv$nzv == TRUE, ])
# Variables con un único valor (aparte de NA)
one_level <- names(which(sapply(data_mice, function(x) length(unique(na.omit(x)))) <= 1))
# Todas las problemáticas
remove_vars <- unique(c(bad_vars, one_level))
if (length(remove_vars) > 0) {
data_mice <- subset(data_mice, select = -remove_vars)
cat("Variables eliminadas por problemas:", remove_vars, "\n")
}
# ===============================
# 3. Definir métodos según tipo
# ===============================
meth <- make.method(data_mice)
for (v in names(data_mice)) {
if (is.numeric(data_mice[[v]])) {
meth[v] <- "pmm"               # numéricas
} else if (is.factor(data_mice[[v]])) {
if (nlevels(data_mice[[v]]) == 2) {
meth[v] <- "logreg"          # binarias
} else {
meth[v] <- "cart"            # categóricas multiclase más estable que polyreg
}
}
}
# ===============================
# 4. Ajustar predictor matrix (reducir predictores)
# ===============================
ini <- mice(data_mice, maxit = 0, method = meth)
pred <- ini$predictorMatrix
# Ejemplo: cada variable solo usa numéricas como predictores
num_vars <- names(data_mice)[sapply(data_mice, is.numeric)]
pred[,] <- 0
pred[, num_vars] <- 1  # todas las variables usan solo numéricas como predictores
# ===============================
# 5. Imputación rápida
# ===============================
imputed_Data <- mice(data_mice, m = 3, maxit = 10,
method = meth, predictorMatrix = pred, seed = 500)
# Resumen
summary(imputed_Data)
# ===============================
# 6. Gráficos de diagnóstico
# ===============================
VIM::aggr(data_mice, col=c('navyblue','yellow'),
numbers=TRUE, sortVars=TRUE,
labels=names(data_mice), cex.axis=.7,
gap=3, ylab=c("Missing data","Pattern"))
# Stripplots para variables numéricas
stripplot(imputed_Data, CreditScore, pch = 19, xlab = "Imputation number")
stripplot(imputed_Data, NumOfProducts, pch = 19, xlab = "Imputation number")
m <- imputed_Data$m
imp_number <- sample(1:m, 1)
completeData <- mice::complete(imputed_Data, imp_number)
m <- imputed_Data$m
imp_number <- sample(1:m, 1)
completeData <- mice::complete(imputed_Data, imp_number)
summary(completeData)
library(mice)
library(ggplot2)
# Supongamos que ya tienes tu objeto imputed_Data de mice
# 1️⃣ Densidades para todas las variables numéricas
mice::densityplot(imputed_Data)
# 2️⃣ Densidad de una variable específica, por ejemplo 'CreditScore'
mice::densityplot(imputed_Data, ~CreditScore, main = "Densidad de CreditScore imputado")
# 3️⃣ Densidad de varias variables específicas
mice::densityplot(imputed_Data, ~CreditScore + NumOfProducts,
main = "Densidades de variables imputadas")
# 4️⃣ Opcional: usando ggplot para más personalización
# Extraer un dataset completo (una imputación)
completeData <- mice::complete(imputed_Data, 1)
# Convertir a formato largo para ggplot
library(tidyr)
data_long <- pivot_longer(completeData, cols = names(completeData), names_to = "Variable", values_to = "Valor")
library(mice)
library(VIM)
library(caret)
data_mice <- data
nzv <- nearZeroVar(data_mice, saveMetrics = TRUE)
bad_vars <- rownames(nzv[nzv$zeroVar == TRUE | nzv$nzv == TRUE, ])
one_level <- names(which(sapply(data_mice, function(x) length(unique(na.omit(x)))) <= 1))
remove_vars <- setdiff(unique(c(bad_vars, one_level)), c("ID", "x"))
if (length(remove_vars) > 0) {
data_mice <- subset(data_mice, select = -remove_vars)
cat("Variables eliminadas por problemas:", remove_vars, "\n")
}
meth <- make.method(data_mice)
for (v in names(data_mice)) {
if (is.numeric(data_mice[[v]])) {
meth[v] <- "pmm"
} else if (is.factor(data_mice[[v]])) {
if (nlevels(data_mice[[v]]) == 2) {
meth[v] <- "logreg"
} else {
meth[v] <- "cart"
}
}
}
# Inicializar mice
ini <- mice(data_mice, maxit = 0, method = meth)
pred <- ini$predictorMatrix
# Configurar la matriz de predictores: no usar ID ni x
exclude_vars <- c("ID", "x")
pred[, exclude_vars] <- 0   # Estas variables no predicen nada
library(mice)
library(VIM)
library(caret)
data_mice <- data
nzv <- nearZeroVar(data_mice, saveMetrics = TRUE)
bad_vars <- rownames(nzv[nzv$zeroVar == TRUE | nzv$nzv == TRUE, ])
one_level <- names(which(sapply(data_mice, function(x) length(unique(na.omit(x)))) <= 1))
remove_vars <- setdiff(unique(c(bad_vars, one_level)), c("ID", "x"))
if (length(remove_vars) > 0) {
data_mice <- subset(data_mice, select = -remove_vars)
cat("Variables eliminadas por problemas:", remove_vars, "\n")
}
meth <- make.method(data_mice)
for (v in names(data_mice)) {
if (is.numeric(data_mice[[v]])) {
meth[v] <- "pmm"
} else if (is.factor(data_mice[[v]])) {
if (nlevels(data_mice[[v]]) == 2) {
meth[v] <- "logreg"
} else {
meth[v] <- "cart"
}
}
}
# Inicializar mice
ini <- mice(data_mice, maxit = 0, method = meth)
pred <- ini$predictorMatrix
exclude_vars <- intersect(c("ID", "x"), names(data_mice))
pred[, exclude_vars] <- 0
imputed_Data <- mice(data_mice, m = 3, maxit = 10,
method = meth, predictorMatrix = pred, seed = 500)
library(mice)
library(VIM)
library(caret)
data_mice <- data
nzv <- nearZeroVar(data_mice, saveMetrics = TRUE)
bad_vars <- rownames(nzv[nzv$zeroVar == TRUE | nzv$nzv == TRUE, ])
one_level <- names(which(sapply(data_mice, function(x) length(unique(na.omit(x)))) <= 1))
remove_vars <- setdiff(unique(c(bad_vars, one_level)), c("ID", "x"))
if (length(remove_vars) > 0) {
data_mice <- subset(data_mice, select = -remove_vars)
cat("Variables eliminadas por problemas:", remove_vars, "\n")
}
meth <- make.method(data_mice)
for (v in names(data_mice)) {
if (is.numeric(data_mice[[v]])) {
meth[v] <- "pmm"
} else if (is.factor(data_mice[[v]])) {
if (nlevels(data_mice[[v]]) == 2) {
meth[v] <- "logreg"
} else {
meth[v] <- "cart"
}
}
}
# Inicializar mice
ini <- mice(data_mice, maxit = 0, method = meth)
pred <- ini$predictorMatrix
exclude_vars <- intersect(c("ID", "x"), names(data_mice))
pred[, exclude_vars] <- 0
imputed_Data <- mice(data_mice, m = 3, maxit = 10,
method = meth, predictorMatrix = pred, seed = 500)
library(mice)
library(VIM)
library(caret)
data_mice <- data
nzv <- nearZeroVar(data_mice, saveMetrics = TRUE)
bad_vars <- rownames(nzv[nzv$zeroVar == TRUE | nzv$nzv == TRUE, ])
one_level <- names(which(sapply(data_mice, function(x) length(unique(na.omit(x)))) <= 1))
dup_vars <- names(data_mice)[duplicated(as.list(data_mice))]
exclude_vars <- intersect(c("ID", "x"), names(data_mice))
remove_vars <- setdiff(unique(c(bad_vars, one_level, dup_vars)), exclude_vars)
if (length(remove_vars) > 0) {
data_mice <- subset(data_mice, select = -remove_vars)
cat("Variables eliminadas por problemas:", remove_vars, "\n")
}
meth <- make.method(data_mice)
for (v in names(data_mice)) {
if (is.numeric(data_mice[[v]])) {
meth[v] <- "pmm"
} else if (is.factor(data_mice[[v]])) {
if (nlevels(data_mice[[v]]) == 2) {
meth[v] <- "logreg"
} else {
meth[v] <- "cart"
}
}
}
ini <- mice(data_mice, maxit = 0, method = meth)
pred <- ini$predictorMatrix
exclude_vars <- intersect(c("ID", "x"), names(data_mice))
if(length(exclude_vars) > 0){
pred[, exclude_vars] <- 0
}
imputed_Data <- mice(data_mice, m = 3, maxit = 10,
method = meth, predictorMatrix = pred, seed = 500)
library(mice)
library(VIM)
library(caret)
data_mice <- data
nzv <- nearZeroVar(data_mice, saveMetrics = TRUE)
bad_vars <- rownames(nzv[nzv$zeroVar == TRUE | nzv$nzv == TRUE, ])
one_level <- names(which(sapply(data_mice, function(x) length(unique(na.omit(x)))) <= 1))
remove_vars <- setdiff(unique(c(bad_vars, one_level)), c("ID", "x"))
if (length(remove_vars) > 0) {
data_mice <- subset(data_mice, select = -remove_vars)
cat("Variables eliminadas por problemas:", remove_vars, "\n")
}
meth <- make.method(data_mice)
for (v in names(data_mice)) {
if (is.numeric(data_mice[[v]])) {
meth[v] <- "pmm"
} else if (is.factor(data_mice[[v]])) {
if (nlevels(data_mice[[v]]) == 2) {
meth[v] <- "logreg"
} else {
meth[v] <- "cart"
}
}
}
# Inicializar mice
ini <- mice(data_mice, maxit = 0, method = meth)
pred <- ini$predictorMatrix
exclude_vars <- intersect(c("ID", "x"), names(data_mice))
pred[, exclude_vars] <- 0
imputed_Data <- mice(data_mice, m = 3, maxit = 10,
method = meth, predictorMatrix = pred, seed = 500)
library(mice)
library(VIM)
library(caret)
data_mice <- data
nzv <- nearZeroVar(data_mice, saveMetrics = TRUE)
bad_vars <- rownames(nzv[nzv$zeroVar == TRUE | nzv$nzv == TRUE, ])
one_level <- names(which(sapply(data_mice, function(x) length(unique(na.omit(x)))) <= 1))
dup_vars <- names(data_mice)[duplicated(as.list(data_mice))]
exclude_vars <- intersect(c("ID","x"), names(data_mice))
remove_vars <- setdiff(unique(c(bad_vars, one_level, dup_vars)), exclude_vars)
if(length(remove_vars) > 0){
data_mice <- subset(data_mice, select = -remove_vars)
cat("Variables eliminadas por problemas:", remove_vars, "\n")
}
num_vars <- setdiff(names(data_mice)[sapply(data_mice, is.numeric)], exclude_vars)
if(length(num_vars) > 1){
cor_matrix <- cor(data_mice[, num_vars], use = "pairwise.complete.obs")
cor_matrix[lower.tri(cor_matrix, diag = TRUE)] <- 0
high_cor <- which(abs(cor_matrix) == 1, arr.ind = TRUE)
if(nrow(high_cor) > 0){
vars_to_remove <- unique(colnames(cor_matrix)[high_cor[,2]])
data_mice <- subset(data_mice, select = -vars_to_remove)
cat("Variables numéricas perfectamente correlacionadas eliminadas:", vars_to_remove, "\n")
}
}
meth <- make.method(data_mice)
for(v in names(data_mice)){
if(v %in% exclude_vars){
meth[v] <- ""  # No imputar ID ni x
} else if(is.numeric(data_mice[[v]])){
meth[v] <- "pmm"
} else if(is.factor(data_mice[[v]])){
if(nlevels(data_mice[[v]]) == 2) meth[v] <- "logreg"
else meth[v] <- "cart"
}
}
ini <- mice(data_mice, maxit = 0, method = meth)
pred <- ini$predictorMatrix
if(length(exclude_vars) > 0){
pred[, exclude_vars] <- 0
}
imputed_Data <- mice(data_mice, m = 3, maxit = 10,
method = meth, predictorMatrix = pred, seed = 500)
library(mice)
library(VIM)
library(caret)
library(ggplot2)
library(tidyr)
quiCat <- which(lapply(data, class) %in% c("character", "factor"))
categories <- names(data)[quiCat]
data_mice2 <- subset(data, select = setdiff(names(data), categories))
summary(data_mice2)
VIM::aggr(data_mice2, col=c('navyblue','yellow'),
numbers=TRUE, sortVars=TRUE,
labels=names(data_mice2), cex.axis=.7,
gap=3, ylab=c("Missing data","Pattern"))
mice_plot <- VIM::aggr(data_mice2, col=c('navyblue','yellow'),
numbers=TRUE, sortVars=TRUE,
labels=names(data_mice), cex.axis=.7,
gap=3, ylab=c("Missing data","Pattern"))
meth <- make.method(data_mice2)
for(v in names(data_mice2)){
if(v %in% c("ID", "x")){
meth[v] <- ""  # No imputar ID ni x
} else {
meth[v] <- "pmm"  # Imputar numéricas
}
}
ini <- mice(data_mice2, maxit = 0, method = meth)
pred <- ini$predictorMatrix
imputed_Data <- mice(data_mice2, m=5, maxit=50,
method=meth, predictorMatrix=pred, seed=500)
summary(imputed_Data)
stripplot(imputed_Data, CreditScore, pch=19, xlab="Imputation number")
stripplot(imputed_Data, NumOfProducts, pch=19, xlab="Imputation number")
densityplot(imputed_Data)
stripplot(imputed_Data, CreditScore, pch=19, xlab="Imputation number")
stripplot(imputed_Data, NumOfProducts, pch=19, xlab="Imputation number")
# Densidad por variable específica
densityplot(imputed_Data, ~CreditScore, main="Densidad de CreditScore imputado")
densityplot(imputed_Data, ~CreditScore + NumOfProducts, main="Densidades de variables imputadas")
data_long <- pivot_longer(completeData, cols = names(completeData),
names_to = "Variable", values_to = "Valor")
completeData <- mice::complete(imputed_Data, sample(1:5, 1))
completeData <- mice::complete(imputed_Data, sample(1:5, 1))
summary(completeData)
setwd("~/Documents/GitHub/Mineria/Entrega_2/Classification tree BBDD reducido_plus")
