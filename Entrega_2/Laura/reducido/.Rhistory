labels=names(data_mice), cex.axis=.7,
gap=3, ylab=c("Missing data","Pattern"))
# Definir métodos según tipo de variable
meth <- make.method(data_mice)
for (v in names(data_mice)) {
if (is.numeric(data_mice[[v]])) {
meth[v] <- "pmm"              # numéricas
} else if (is.factor(data_mice[[v]])) {
if (nlevels(data_mice[[v]]) == 2) {
meth[v] <- "logreg"         # binarias
} else {
meth[v] <- "polyreg"        # categóricas con más de 2 niveles
}
}
}
# Imputación mixta
imputed_Data <- mice(data_mice, m = 5, maxit = 50, method = meth, seed = 500)
library(mice)
library(VIM)
library(caret)
data_mice <- data
# ===============================
# 2. Quitar variables problemáticas
# ===============================
# Variables con varianza cero o casi cero
nzv <- nearZeroVar(data_mice, saveMetrics = TRUE)
bad_vars <- rownames(nzv[nzv$zeroVar == TRUE | nzv$nzv == TRUE, ])
# Variables con un único valor (aparte de NA)
one_level <- names(which(sapply(data_mice, function(x) length(unique(na.omit(x)))) <= 1))
# Todas las problemáticas
remove_vars <- unique(c(bad_vars, one_level))
if (length(remove_vars) > 0) {
data_mice <- subset(data_mice, select = -remove_vars)
cat("Variables eliminadas por problemas:", remove_vars, "\n")
}
# ===============================
# 3. Definir métodos según tipo
# ===============================
meth <- make.method(data_mice)
for (v in names(data_mice)) {
if (is.numeric(data_mice[[v]])) {
meth[v] <- "pmm"               # numéricas
} else if (is.factor(data_mice[[v]])) {
if (nlevels(data_mice[[v]]) == 2) {
meth[v] <- "logreg"          # binarias
} else {
meth[v] <- "cart"            # categóricas multiclase más estable que polyreg
}
}
}
# ===============================
# 4. Ajustar predictor matrix (reducir predictores)
# ===============================
ini <- mice(data_mice, maxit = 0, method = meth)
pred <- ini$predictorMatrix
# Ejemplo: cada variable solo usa numéricas como predictores
num_vars <- names(data_mice)[sapply(data_mice, is.numeric)]
pred[,] <- 0
pred[, num_vars] <- 1  # todas las variables usan solo numéricas como predictores
# ===============================
# 5. Imputación rápida
# ===============================
imputed_Data <- mice(data_mice, m = 3, maxit = 10,
method = meth, predictorMatrix = pred, seed = 500)
# Resumen
summary(imputed_Data)
# ===============================
# 6. Gráficos de diagnóstico
# ===============================
VIM::aggr(data_mice, col=c('navyblue','yellow'),
numbers=TRUE, sortVars=TRUE,
labels=names(data_mice), cex.axis=.7,
gap=3, ylab=c("Missing data","Pattern"))
# Stripplots para variables numéricas
stripplot(imputed_Data, CreditScore, pch = 19, xlab = "Imputation number")
stripplot(imputed_Data, NumOfProducts, pch = 19, xlab = "Imputation number")
m <- imputed_Data$m
imp_number <- sample(1:m, 1)
completeData <- mice::complete(imputed_Data, imp_number)
m <- imputed_Data$m
imp_number <- sample(1:m, 1)
completeData <- mice::complete(imputed_Data, imp_number)
summary(completeData)
library(mice)
library(ggplot2)
# Supongamos que ya tienes tu objeto imputed_Data de mice
# 1️⃣ Densidades para todas las variables numéricas
mice::densityplot(imputed_Data)
# 2️⃣ Densidad de una variable específica, por ejemplo 'CreditScore'
mice::densityplot(imputed_Data, ~CreditScore, main = "Densidad de CreditScore imputado")
# 3️⃣ Densidad de varias variables específicas
mice::densityplot(imputed_Data, ~CreditScore + NumOfProducts,
main = "Densidades de variables imputadas")
# 4️⃣ Opcional: usando ggplot para más personalización
# Extraer un dataset completo (una imputación)
completeData <- mice::complete(imputed_Data, 1)
# Convertir a formato largo para ggplot
library(tidyr)
data_long <- pivot_longer(completeData, cols = names(completeData), names_to = "Variable", values_to = "Valor")
library(mice)
library(VIM)
library(caret)
data_mice <- data
nzv <- nearZeroVar(data_mice, saveMetrics = TRUE)
bad_vars <- rownames(nzv[nzv$zeroVar == TRUE | nzv$nzv == TRUE, ])
one_level <- names(which(sapply(data_mice, function(x) length(unique(na.omit(x)))) <= 1))
remove_vars <- setdiff(unique(c(bad_vars, one_level)), c("ID", "x"))
if (length(remove_vars) > 0) {
data_mice <- subset(data_mice, select = -remove_vars)
cat("Variables eliminadas por problemas:", remove_vars, "\n")
}
meth <- make.method(data_mice)
for (v in names(data_mice)) {
if (is.numeric(data_mice[[v]])) {
meth[v] <- "pmm"
} else if (is.factor(data_mice[[v]])) {
if (nlevels(data_mice[[v]]) == 2) {
meth[v] <- "logreg"
} else {
meth[v] <- "cart"
}
}
}
# Inicializar mice
ini <- mice(data_mice, maxit = 0, method = meth)
pred <- ini$predictorMatrix
# Configurar la matriz de predictores: no usar ID ni x
exclude_vars <- c("ID", "x")
pred[, exclude_vars] <- 0   # Estas variables no predicen nada
library(mice)
library(VIM)
library(caret)
data_mice <- data
nzv <- nearZeroVar(data_mice, saveMetrics = TRUE)
bad_vars <- rownames(nzv[nzv$zeroVar == TRUE | nzv$nzv == TRUE, ])
one_level <- names(which(sapply(data_mice, function(x) length(unique(na.omit(x)))) <= 1))
remove_vars <- setdiff(unique(c(bad_vars, one_level)), c("ID", "x"))
if (length(remove_vars) > 0) {
data_mice <- subset(data_mice, select = -remove_vars)
cat("Variables eliminadas por problemas:", remove_vars, "\n")
}
meth <- make.method(data_mice)
for (v in names(data_mice)) {
if (is.numeric(data_mice[[v]])) {
meth[v] <- "pmm"
} else if (is.factor(data_mice[[v]])) {
if (nlevels(data_mice[[v]]) == 2) {
meth[v] <- "logreg"
} else {
meth[v] <- "cart"
}
}
}
# Inicializar mice
ini <- mice(data_mice, maxit = 0, method = meth)
pred <- ini$predictorMatrix
exclude_vars <- intersect(c("ID", "x"), names(data_mice))
pred[, exclude_vars] <- 0
imputed_Data <- mice(data_mice, m = 3, maxit = 10,
method = meth, predictorMatrix = pred, seed = 500)
library(mice)
library(VIM)
library(caret)
data_mice <- data
nzv <- nearZeroVar(data_mice, saveMetrics = TRUE)
bad_vars <- rownames(nzv[nzv$zeroVar == TRUE | nzv$nzv == TRUE, ])
one_level <- names(which(sapply(data_mice, function(x) length(unique(na.omit(x)))) <= 1))
remove_vars <- setdiff(unique(c(bad_vars, one_level)), c("ID", "x"))
if (length(remove_vars) > 0) {
data_mice <- subset(data_mice, select = -remove_vars)
cat("Variables eliminadas por problemas:", remove_vars, "\n")
}
meth <- make.method(data_mice)
for (v in names(data_mice)) {
if (is.numeric(data_mice[[v]])) {
meth[v] <- "pmm"
} else if (is.factor(data_mice[[v]])) {
if (nlevels(data_mice[[v]]) == 2) {
meth[v] <- "logreg"
} else {
meth[v] <- "cart"
}
}
}
# Inicializar mice
ini <- mice(data_mice, maxit = 0, method = meth)
pred <- ini$predictorMatrix
exclude_vars <- intersect(c("ID", "x"), names(data_mice))
pred[, exclude_vars] <- 0
imputed_Data <- mice(data_mice, m = 3, maxit = 10,
method = meth, predictorMatrix = pred, seed = 500)
library(mice)
library(VIM)
library(caret)
data_mice <- data
nzv <- nearZeroVar(data_mice, saveMetrics = TRUE)
bad_vars <- rownames(nzv[nzv$zeroVar == TRUE | nzv$nzv == TRUE, ])
one_level <- names(which(sapply(data_mice, function(x) length(unique(na.omit(x)))) <= 1))
dup_vars <- names(data_mice)[duplicated(as.list(data_mice))]
exclude_vars <- intersect(c("ID", "x"), names(data_mice))
remove_vars <- setdiff(unique(c(bad_vars, one_level, dup_vars)), exclude_vars)
if (length(remove_vars) > 0) {
data_mice <- subset(data_mice, select = -remove_vars)
cat("Variables eliminadas por problemas:", remove_vars, "\n")
}
meth <- make.method(data_mice)
for (v in names(data_mice)) {
if (is.numeric(data_mice[[v]])) {
meth[v] <- "pmm"
} else if (is.factor(data_mice[[v]])) {
if (nlevels(data_mice[[v]]) == 2) {
meth[v] <- "logreg"
} else {
meth[v] <- "cart"
}
}
}
ini <- mice(data_mice, maxit = 0, method = meth)
pred <- ini$predictorMatrix
exclude_vars <- intersect(c("ID", "x"), names(data_mice))
if(length(exclude_vars) > 0){
pred[, exclude_vars] <- 0
}
imputed_Data <- mice(data_mice, m = 3, maxit = 10,
method = meth, predictorMatrix = pred, seed = 500)
library(mice)
library(VIM)
library(caret)
data_mice <- data
nzv <- nearZeroVar(data_mice, saveMetrics = TRUE)
bad_vars <- rownames(nzv[nzv$zeroVar == TRUE | nzv$nzv == TRUE, ])
one_level <- names(which(sapply(data_mice, function(x) length(unique(na.omit(x)))) <= 1))
remove_vars <- setdiff(unique(c(bad_vars, one_level)), c("ID", "x"))
if (length(remove_vars) > 0) {
data_mice <- subset(data_mice, select = -remove_vars)
cat("Variables eliminadas por problemas:", remove_vars, "\n")
}
meth <- make.method(data_mice)
for (v in names(data_mice)) {
if (is.numeric(data_mice[[v]])) {
meth[v] <- "pmm"
} else if (is.factor(data_mice[[v]])) {
if (nlevels(data_mice[[v]]) == 2) {
meth[v] <- "logreg"
} else {
meth[v] <- "cart"
}
}
}
# Inicializar mice
ini <- mice(data_mice, maxit = 0, method = meth)
pred <- ini$predictorMatrix
exclude_vars <- intersect(c("ID", "x"), names(data_mice))
pred[, exclude_vars] <- 0
imputed_Data <- mice(data_mice, m = 3, maxit = 10,
method = meth, predictorMatrix = pred, seed = 500)
library(mice)
library(VIM)
library(caret)
data_mice <- data
nzv <- nearZeroVar(data_mice, saveMetrics = TRUE)
bad_vars <- rownames(nzv[nzv$zeroVar == TRUE | nzv$nzv == TRUE, ])
one_level <- names(which(sapply(data_mice, function(x) length(unique(na.omit(x)))) <= 1))
dup_vars <- names(data_mice)[duplicated(as.list(data_mice))]
exclude_vars <- intersect(c("ID","x"), names(data_mice))
remove_vars <- setdiff(unique(c(bad_vars, one_level, dup_vars)), exclude_vars)
if(length(remove_vars) > 0){
data_mice <- subset(data_mice, select = -remove_vars)
cat("Variables eliminadas por problemas:", remove_vars, "\n")
}
num_vars <- setdiff(names(data_mice)[sapply(data_mice, is.numeric)], exclude_vars)
if(length(num_vars) > 1){
cor_matrix <- cor(data_mice[, num_vars], use = "pairwise.complete.obs")
cor_matrix[lower.tri(cor_matrix, diag = TRUE)] <- 0
high_cor <- which(abs(cor_matrix) == 1, arr.ind = TRUE)
if(nrow(high_cor) > 0){
vars_to_remove <- unique(colnames(cor_matrix)[high_cor[,2]])
data_mice <- subset(data_mice, select = -vars_to_remove)
cat("Variables numéricas perfectamente correlacionadas eliminadas:", vars_to_remove, "\n")
}
}
meth <- make.method(data_mice)
for(v in names(data_mice)){
if(v %in% exclude_vars){
meth[v] <- ""  # No imputar ID ni x
} else if(is.numeric(data_mice[[v]])){
meth[v] <- "pmm"
} else if(is.factor(data_mice[[v]])){
if(nlevels(data_mice[[v]]) == 2) meth[v] <- "logreg"
else meth[v] <- "cart"
}
}
ini <- mice(data_mice, maxit = 0, method = meth)
pred <- ini$predictorMatrix
if(length(exclude_vars) > 0){
pred[, exclude_vars] <- 0
}
imputed_Data <- mice(data_mice, m = 3, maxit = 10,
method = meth, predictorMatrix = pred, seed = 500)
library(mice)
library(VIM)
library(caret)
library(ggplot2)
library(tidyr)
quiCat <- which(lapply(data, class) %in% c("character", "factor"))
categories <- names(data)[quiCat]
data_mice2 <- subset(data, select = setdiff(names(data), categories))
summary(data_mice2)
VIM::aggr(data_mice2, col=c('navyblue','yellow'),
numbers=TRUE, sortVars=TRUE,
labels=names(data_mice2), cex.axis=.7,
gap=3, ylab=c("Missing data","Pattern"))
mice_plot <- VIM::aggr(data_mice2, col=c('navyblue','yellow'),
numbers=TRUE, sortVars=TRUE,
labels=names(data_mice), cex.axis=.7,
gap=3, ylab=c("Missing data","Pattern"))
meth <- make.method(data_mice2)
for(v in names(data_mice2)){
if(v %in% c("ID", "x")){
meth[v] <- ""  # No imputar ID ni x
} else {
meth[v] <- "pmm"  # Imputar numéricas
}
}
ini <- mice(data_mice2, maxit = 0, method = meth)
pred <- ini$predictorMatrix
imputed_Data <- mice(data_mice2, m=5, maxit=50,
method=meth, predictorMatrix=pred, seed=500)
summary(imputed_Data)
stripplot(imputed_Data, CreditScore, pch=19, xlab="Imputation number")
stripplot(imputed_Data, NumOfProducts, pch=19, xlab="Imputation number")
densityplot(imputed_Data)
stripplot(imputed_Data, CreditScore, pch=19, xlab="Imputation number")
stripplot(imputed_Data, NumOfProducts, pch=19, xlab="Imputation number")
# Densidad por variable específica
densityplot(imputed_Data, ~CreditScore, main="Densidad de CreditScore imputado")
densityplot(imputed_Data, ~CreditScore + NumOfProducts, main="Densidades de variables imputadas")
data_long <- pivot_longer(completeData, cols = names(completeData),
names_to = "Variable", values_to = "Valor")
completeData <- mice::complete(imputed_Data, sample(1:5, 1))
completeData <- mice::complete(imputed_Data, sample(1:5, 1))
summary(completeData)
setwd("~/Documents/GitHub/Mineria/Entrega_2/Laura/reducido")
load("~/Documents/GitHub/Mineria/DATA/dataaaaaaaaaaaaaa.RData")
data_transformada_n<-data_transformada
View(data_transformada_n)
keys_e <- c("Gender", "Age", "Geography", "MaritalStatus", "EducationLevel", "LoanStatus","HasCrCard","NetPromoterScore","CustomerSegment","LoanStatus")
keys_f <- c("Gender", "Age", "Geography", "MaritalStatus", "EducationLevel", "LoanStatus","HasCrCard","NetPromoterScore","CustomerSegment","LoanStatus")
data_sin_duplicados_f <- data_transformada_n[!(duplicated(data_transformada_n[, keys_f]) & data_transformada_n$group == "train"), ]
save(data_sin_duplicados_f, file = "data_transformada_fi.RData")
View(data_reducida)
# Con la base de datos reducido
data_reducida_r<-data_reducida
# Con la base de datos reducido
data_reducida_r<-data_reducida
data_reducida_r[duplicated(data_reducida_r$group=="train"), ]
# Con la base de datos reducido
data_reducida_r<-data_reducida
data_reducida_r[duplicated(data_reducida_r), ]
# Con la base de datos reducido
data_reducida_r<-data_reducida
reducido <- data_reducida_r[data_reducida_r$grupo == "train" &
duplicated(data_reducida_r[data_reducida_r$grupo == "test", ]), ]
data_reducida_r<-data_reducida
reducido <- data_reducida_r[data_reducida_r$grupo == "train" &
duplicated(data_reducida_r[data_reducida_r$grupo == "train", ]), ]
View(data)
View(reducido)
View(reducido)
load("~/Documents/GitHub/Mineria/DATA/dataaaaaaaaaaaaaa.RData")
data_transformada_n<-data_transformada
keys <- c("Gender", "Age", "Geography", "MaritalStatus", "EducationLevel")
keys <- c("Gender", "Age", "Geography", "MaritalStatus", "EducationLevel")
# Mantener la primera ocurrencia de cada duplicado dentro de 'train'
duplicado_train <- duplicated(data_transformada_n[data_transformada_n$group == "train", keys])
# Crear un vector lógico para todas las filas
keep <- rep(TRUE, nrow(data_transformada_n))
# Marcar como FALSE las filas duplicadas de 'train' (excepto la primera)
keep[data_transformada_n$group == "train"][duplicado_train] <- FALSE
# Filtrar los datos
data_sin_duplicados <- data_transformada_n[keep, ]
# Más estricto:
keys_e <- c("Gender", "Age", "Geography", "MaritalStatus")
# Identificar duplicados dentro de 'train'
duplicado_train <- duplicated(data_transformada_n[data_transformada_n$group == "train", keys_e])
# Crear vector lógico para mantener todas las filas por defecto
keep <- rep(TRUE, nrow(data_transformada_n))
# Marcar como FALSE las filas duplicadas de 'train' (excepto la primera)
keep[data_transformada_n$group == "train"][duplicado_train] <- FALSE
# Filtrar el dataframe
data_sin_duplicados_e <- data_transformada_n[keep, ]
# Revisar
sum(data_sin_duplicados_e$group == "train")
knitr::opts_chunk$set(echo = TRUE)
load("~/Documents/GitHub/Mineria/DATA/dataaaaaaaaaaaaaa.RData")
data_transformada_n<-data_transformada
summary(data_transformada_n)
duplicated(data_transformada_n)
data_transformada_n[duplicated(data_transformada_n), ]
View(data_imputado)
keys <- c("Gender", "Age", "Geography", "MaritalStatus", "EducationLevel")
keys <- c("Gender", "Age", "Geography", "MaritalStatus", "EducationLevel")
# Mantener la primera ocurrencia de cada duplicado dentro de 'train'
duplicado_train <- duplicated(data_transformada_n[data_transformada_n$group == "train", keys])
keys <- c("Gender", "Age", "Geography", "MaritalStatus", "EducationLevel")
duplicado_train <- duplicated(data_transformada_n[data_transformada_n$group == "train", keys])
# Crear un vector lógico para todas las filas
keep <- rep(TRUE, nrow(data_transformada_n))
# Marcar como FALSE las filas duplicadas de 'train' (excepto la primera)
keep[data_transformada_n$group == "train"][duplicado_train] <- FALSE
data_sin_duplicados <- data_transformada_n[keep, ]
dim(data_sin_duplicados)
keys_e <- c("Gender", "Age", "Geography", "MaritalStatus")
# Identificar duplicados dentro de 'train'
duplicado_train <- duplicated(data_transformada_n[data_transformada_n$group == "train", keys_e])
# Crear vector lógico para mantener todas las filas por defecto
keep <- rep(TRUE, nrow(data_transformada_n))
# Marcar como FALSE las filas duplicadas de 'train' (excepto la primera)
keep[data_transformada_n$group == "train"][duplicado_train] <- FALSE
# Filtrar el dataframe
data_sin_duplicados_e <- data_transformada_n[keep, ]
keys_e <- c("Gender", "Age", "Geography", "MaritalStatus")
# Identificar duplicados dentro de 'train'
duplicado_train <- duplicated(data_transformada_n[data_transformada_n$group == "train", keys_e])
# Crear vector lógico para mantener todas las filas por defecto
keep <- rep(TRUE, nrow(data_transformada_n))
# Marcar como FALSE las filas duplicadas de 'train' (excepto la primera)
keep[data_transformada_n$group == "train"][duplicado_train] <- FALSE
# Filtrar el dataframe
data_sin_duplicados_e <- data_transformada_n[keep, ]
dim(data_sin_duplicados_e)
keys_f <- c("Gender", "Age", "Geography", "MaritalStatus", "EducationLevel", "LoanStatus","HasCrCard","NetPromoterScore","CustomerSegment","LoanStatus")
data_sin_duplicados_f <- data_transformada_n[!(duplicated(data_transformada_n[, keys_f]) & data_transformada_n$group == "train"), ]
keys_f <- c("Gender", "Age", "Geography", "MaritalStatus", "EducationLevel", "LoanStatus","HasCrCard","NetPromoterScore","CustomerSegment","LoanStatus")
# Identificar duplicados solo dentro de train, según keys_f
dup_train <- duplicated(data_transformada_n[data_transformada_n$group == "train", keys_f])
# Crear vector keep
keep <- rep(TRUE, nrow(data_transformada_n))
# Marcar para eliminar solamente los duplicados de train (excepto la primera fila)
keep[data_transformada_n$group == "train"][dup_train] <- FALSE
# Filtrar
data_sin_duplicados_f <- data_transformada_n[keep, ]
keys_f <- c("Gender", "Age", "Geography", "MaritalStatus", "EducationLevel", "LoanStatus","HasCrCard","NetPromoterScore","CustomerSegment","LoanStatus")
# Identificar duplicados solo dentro de train, según keys_f
dup_train <- duplicated(data_transformada_n[data_transformada_n$group == "train", keys_f])
# Crear vector keep
keep <- rep(TRUE, nrow(data_transformada_n))
# Marcar para eliminar solamente los duplicados de train (excepto la primera fila)
keep[data_transformada_n$group == "train"][dup_train] <- FALSE
# Filtrar
data_sin_duplicados_f <- data_transformada_n[keep, ]
dim(data_sin_duplicados_f)
data_reducida_r<-data_reducida
data_reducida_r<-data_reducida
reducido <- data_reducida_r[data_reducida_r$grupo == "train" &
duplicated(data_reducida_r[data_reducida_r$grupo == "train", ]), ]
wich(reducido)
data_reducida_r<-data_reducida
reducido <- data_reducida_r[data_reducida_r$grupo == "train" &
duplicated(data_reducida_r[data_reducida_r$grupo == "train", ]), ]
which(reducido)
data_reducida_r<-data_reducida
reducido <- data_reducida_r[data_reducida_r$grupo == "train" &
duplicated(data_reducida_r[data_reducida_r$grupo == "train", ]), ]
count(reducido)
data_reducida_r<-data_reducida
reducido <- data_reducida_r[data_reducida_r$grupo == "train" &
duplicated(data_reducida_r[data_reducida_r$grupo == "train", ]), ]
reducido
dup_train <- duplicated(data_reducida_r[data_reducida_r$grupo == "train", ])
data_reducida_r<-data_reducida
dup_train <- duplicated(data_reducida_r[data_reducida_r$grupo == "train", ])
# Extraer solo las filas duplicadas del grupo train
reducido <- data_reducida_r[data_reducida_r$grupo == "train", ][dup_train, ]
data_reducida_r<-data_reducida
dup_train <- duplicated(data_reducida_r[data_reducida_r$grupo == "train", ])
# Extraer solo las filas duplicadas del grupo train
reducido <- data_reducida_r[data_reducida_r$grupo == "train", ][dup_train, ]
dim(reducido)
data_reducida_r<-data_reducida
sum(duplicated(data_reducida_r))
data_reducida_r<-data_reducida
sum(duplicated(data_reducida_r))
train_rows <- data_reducida_r$grupo == "train"
dup_train <- duplicated(data_reducida_r[train_rows, ])
#Conservar
keep <- rep(TRUE, nrow(data_reducida_r))
# 4. Eliminar copias adicionales dentro de train
keep[train_rows][dup_train] <- FALSE
data_sin_red_duplicados <- data_reducida_r[keep, ]
sum(dup_train) #cuantas se han eliminado
sum(data_sin_red_duplicados$grupo == "train") #quedan
dim(data_sin_red_duplicados)
data_reducida_r<-data_reducida
sum(duplicated(data_reducida_r$grupo=="train"))
train_rows <- data_reducida_r$grupo == "train"
dup_train <- duplicated(data_reducida_r[train_rows, ])
#Conservar
keep <- rep(TRUE, nrow(data_reducida_r))
# 4. Eliminar copias adicionales dentro de train
keep[train_rows][dup_train] <- FALSE
data_sin_red_duplicados <- data_reducida_r[keep, ]
sum(dup_train) #cuantas se han eliminado
sum(data_sin_red_duplicados$grupo == "train") #quedan
dim(data_sin_red_duplicados)
data_reducida_r<-data_reducida
sum(duplicated(data_reducida_r$grupo=="train"))
data_reducida_plus_sin<-data_reducida_plus
sum(duplicated(data_reducida_plus_sin$grupo=="train"))
save(data_sin_duplicados, file = "data_transformada_r.RData")
save(data_sin_duplicados_e, file = "data_transformada_re.RData")
save(data_sin_duplicados_f, file = "data_transformada_fi.RData")
