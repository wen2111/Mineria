# Imputar según reglas
data_ar_imputed$Exited[rows_to_impute_1] <- 1
data_ar_imputed$Exited[rows_to_impute_0] <- 0
# Añadir ID
data_ar_imputed$ID <- data[7001:10000, ]$ID
# Seleccionar solo ID y Exited
data_ar_imputed2 <- data_ar_imputed[, c("ID", "Exited")]
# Convertir Exited a "Yes"/"No" y eliminar NA
data_ar_imputed2 <- data_ar_imputed2 %>%
filter(!is.na(Exited)) %>%
mutate(Exited = ifelse(Exited == 1, "Yes", "No"))
table(data_ar_imputed2$Exited)
saveRDS(
data_ar_imputed2,
"~/GitHub/Mineria/DATA/A NUEVOS TEST CON IMPUTADOS DE REPETIDOS/test_df_imputed_AR_01.rds"
)
table(data_ar_imputed2$Exited)
# ===============================
# 3️⃣ Seleccionar reglas de interés
# ===============================
# Reglas para Exited = 1 con confianza > 0.93
reglas_exit1 <- subset(reglas_Noredund, rhs %pin% "Exited=1" & confidence > 0.55)
# Reglas para Exited = 0 con confianza > 0.93
reglas_exit0 <- subset(reglas_Noredund, rhs %pin% "Exited=0" & confidence >= 0.99)
# ===============================
# 4️⃣ Inicializar vectores de imputación
# ===============================
rows_to_impute_1 <- rep(FALSE, length(data_ar_trans))
rows_to_impute_0 <- rep(FALSE, length(data_ar_trans))
# ===============================
# 5️⃣ Imputar Exited = 1
# ===============================
for(i in seq_along(reglas_exit1)) {
lhs_rule <- lhs(reglas_exit1[i])
match_rows <- is.subset(lhs_rule, data_ar_trans)
rows_to_impute_1 <- rows_to_impute_1 | as.logical(match_rows)
}
# ===============================
# 6️⃣ Imputar Exited = 0
# ===============================
for(i in seq_along(reglas_exit0)) {
lhs_rule <- lhs(reglas_exit0[i])
match_rows <- is.subset(lhs_rule, data_ar_trans)
rows_to_impute_0 <- rows_to_impute_0 | as.logical(match_rows)
}
# ===============================
# 7️⃣ Aplicar imputaciones en data_ar
# ===============================
data_ar_imputed <- data_ar
# Imputar según reglas
data_ar_imputed$Exited[rows_to_impute_1] <- 1
data_ar_imputed$Exited[rows_to_impute_0] <- 0
# Añadir ID
data_ar_imputed$ID <- data[7001:10000, ]$ID
# Seleccionar solo ID y Exited
data_ar_imputed2 <- data_ar_imputed[, c("ID", "Exited")]
# Convertir Exited a "Yes"/"No" y eliminar NA
data_ar_imputed2 <- data_ar_imputed2 %>%
filter(!is.na(Exited)) %>%
mutate(Exited = ifelse(Exited == 1, "Yes", "No"))
table(data_ar_imputed2$Exited)
saveRDS(
data_ar_imputed2,
"~/GitHub/Mineria/DATA/A NUEVOS TEST CON IMPUTADOS DE REPETIDOS/test_df_imputed_AR_01.rds"
)
#aplicamos los imputados
test_df_imputed <- readRDS("~/GitHub/Mineria/DATA/A NUEVOS TEST CON IMPUTADOS DE REPETIDOS/test_df_imputed_AR_01.rds")
library(dplyr)
#ID originales de test
load("~/GitHub/Mineria/DATA/data.RData")
id<-data[7001:10000,]$ID
# Unir por ID y actualizar Exited
submission <- data.frame(ID = id, Exited = pred_kaggle_class)
table(submission$Exited)
submission <- submission %>%
left_join(
test_df_imputed %>% select(ID, Exited) %>% rename(Exited_new = Exited),
by = "ID"
) %>%
mutate(
Exited = if_else(!is.na(Exited_new), Exited_new, Exited)
) %>%
select(-Exited_new)
table(submission$Exited)
# ===============================
# 3️⃣ Seleccionar reglas de interés
# ===============================
# Reglas para Exited = 1 con confianza > 0.93
reglas_exit1 <- subset(reglas_Noredund, rhs %pin% "Exited=1" & confidence >= 0.55)
# Reglas para Exited = 0 con confianza > 0.93
reglas_exit0 <- subset(reglas_Noredund, rhs %pin% "Exited=0" & confidence >= 0.99)
# ===============================
# 4️⃣ Inicializar vectores de imputación
# ===============================
rows_to_impute_1 <- rep(FALSE, length(data_ar_trans))
rows_to_impute_0 <- rep(FALSE, length(data_ar_trans))
# ===============================
# 5️⃣ Imputar Exited = 1
# ===============================
for(i in seq_along(reglas_exit1)) {
lhs_rule <- lhs(reglas_exit1[i])
match_rows <- is.subset(lhs_rule, data_ar_trans)
rows_to_impute_1 <- rows_to_impute_1 | as.logical(match_rows)
}
# ===============================
# 6️⃣ Imputar Exited = 0
# ===============================
for(i in seq_along(reglas_exit0)) {
lhs_rule <- lhs(reglas_exit0[i])
match_rows <- is.subset(lhs_rule, data_ar_trans)
rows_to_impute_0 <- rows_to_impute_0 | as.logical(match_rows)
}
# ===============================
# 7️⃣ Aplicar imputaciones en data_ar
# ===============================
data_ar_imputed <- data_ar
# Imputar según reglas
data_ar_imputed$Exited[rows_to_impute_1] <- 1
data_ar_imputed$Exited[rows_to_impute_0] <- 0
# Añadir ID
data_ar_imputed$ID <- data[7001:10000, ]$ID
# Seleccionar solo ID y Exited
data_ar_imputed2 <- data_ar_imputed[, c("ID", "Exited")]
# Convertir Exited a "Yes"/"No" y eliminar NA
data_ar_imputed2 <- data_ar_imputed2 %>%
filter(!is.na(Exited)) %>%
mutate(Exited = ifelse(Exited == 1, "Yes", "No"))
table(data_ar_imputed2$Exited)
saveRDS(
data_ar_imputed2,
"~/GitHub/Mineria/DATA/A NUEVOS TEST CON IMPUTADOS DE REPETIDOS/test_df_imputed_AR_01.rds"
)
#aplicamos los imputados
test_df_imputed <- readRDS("~/GitHub/Mineria/DATA/A NUEVOS TEST CON IMPUTADOS DE REPETIDOS/test_df_imputed_AR_01.rds")
library(dplyr)
#ID originales de test
load("~/GitHub/Mineria/DATA/data.RData")
id<-data[7001:10000,]$ID
# Unir por ID y actualizar Exited
submission <- data.frame(ID = id, Exited = pred_kaggle_class)
table(submission$Exited)
submission <- submission %>%
left_join(
test_df_imputed %>% select(ID, Exited) %>% rename(Exited_new = Exited),
by = "ID"
) %>%
mutate(
Exited = if_else(!is.na(Exited_new), Exited_new, Exited)
) %>%
select(-Exited_new)
table(submission$Exited)
# ===============================
# 3️⃣ Seleccionar reglas de interés
# ===============================
# Reglas para Exited = 1 con confianza > 0.93
reglas_exit1 <- subset(reglas_Noredund, rhs %pin% "Exited=1" & confidence >= 0.50)
# Reglas para Exited = 0 con confianza > 0.93
reglas_exit0 <- subset(reglas_Noredund, rhs %pin% "Exited=0" & confidence >= 0.95)
# ===============================
# 4️⃣ Inicializar vectores de imputación
# ===============================
rows_to_impute_1 <- rep(FALSE, length(data_ar_trans))
rows_to_impute_0 <- rep(FALSE, length(data_ar_trans))
# ===============================
# 5️⃣ Imputar Exited = 1
# ===============================
for(i in seq_along(reglas_exit1)) {
lhs_rule <- lhs(reglas_exit1[i])
match_rows <- is.subset(lhs_rule, data_ar_trans)
rows_to_impute_1 <- rows_to_impute_1 | as.logical(match_rows)
}
# ===============================
# 6️⃣ Imputar Exited = 0
# ===============================
for(i in seq_along(reglas_exit0)) {
lhs_rule <- lhs(reglas_exit0[i])
match_rows <- is.subset(lhs_rule, data_ar_trans)
rows_to_impute_0 <- rows_to_impute_0 | as.logical(match_rows)
}
# ===============================
# 7️⃣ Aplicar imputaciones en data_ar
# ===============================
data_ar_imputed <- data_ar
# Imputar según reglas
data_ar_imputed$Exited[rows_to_impute_1] <- 1
data_ar_imputed$Exited[rows_to_impute_0] <- 0
# Añadir ID
data_ar_imputed$ID <- data[7001:10000, ]$ID
# Seleccionar solo ID y Exited
data_ar_imputed2 <- data_ar_imputed[, c("ID", "Exited")]
# Convertir Exited a "Yes"/"No" y eliminar NA
data_ar_imputed2 <- data_ar_imputed2 %>%
filter(!is.na(Exited)) %>%
mutate(Exited = ifelse(Exited == 1, "Yes", "No"))
table(data_ar_imputed2$Exited)
saveRDS(
data_ar_imputed2,
"~/GitHub/Mineria/DATA/A NUEVOS TEST CON IMPUTADOS DE REPETIDOS/test_df_imputed_AR_01.rds"
)
#aplicamos los imputados
test_df_imputed <- readRDS("~/GitHub/Mineria/DATA/A NUEVOS TEST CON IMPUTADOS DE REPETIDOS/test_df_imputed_AR_01.rds")
library(dplyr)
#ID originales de test
load("~/GitHub/Mineria/DATA/data.RData")
id<-data[7001:10000,]$ID
# Unir por ID y actualizar Exited
submission <- data.frame(ID = id, Exited = pred_kaggle_class)
table(submission$Exited)
submission <- submission %>%
left_join(
test_df_imputed %>% select(ID, Exited) %>% rename(Exited_new = Exited),
by = "ID"
) %>%
mutate(
Exited = if_else(!is.na(Exited_new), Exited_new, Exited)
) %>%
select(-Exited_new)
table(submission$Exited)
812/3000
# Reglas para Exited = 0 con confianza > 0.93
reglas_exit0 <- subset(reglas_Noredund, rhs %pin% "Exited=0" & confidence ==1)
# ===============================
# 3️⃣ Seleccionar reglas de interés
# ===============================
# Reglas para Exited = 1 con confianza > 0.93
reglas_exit1 <- subset(reglas_Noredund, rhs %pin% "Exited=1" & confidence >= 0.50)
test_df_imputed <- readRDS("~/GitHub/Mineria/DATA/A NUEVOS TEST CON IMPUTADOS DE REPETIDOS/test_df_imputed_AR_01.rds")
library(dplyr)
#ID originales de test
load("~/GitHub/Mineria/DATA/data.RData")
id<-data[7001:10000,]$ID
# Unir por ID y actualizar Exited
submission <- data.frame(ID = id, Exited = pred_kaggle_class)
table(submission$Exited)
submission <- submission %>%
left_join(
test_df_imputed %>% select(ID, Exited) %>% rename(Exited_new = Exited),
by = "ID"
) %>%
mutate(
Exited = if_else(!is.na(Exited_new), Exited_new, Exited)
) %>%
select(-Exited_new)
table(submission$Exited)
#submission
write.csv(submission, "~/GitHub/Mineria/submissions queue/para cuando no lleguemos a 3 en un dia/xgboost_imputing_1_v2.csv", row.names = FALSE)
test_df_imputed <- readRDS("~/GitHub/Mineria/DATA/A NUEVOS TEST CON IMPUTADOS DE REPETIDOS/test_df_imputed_AR_01.rds")
library(dplyr)
#ID originales de test
load("~/GitHub/Mineria/DATA/data.RData")
id<-data[7001:10000,]$ID
# Unir por ID y actualizar Exited
submission <- data.frame(ID = id, Exited = pred_kaggle_class)
table(submission$Exited)
submission <- submission %>%
left_join(
test_df_imputed %>% select(ID, Exited) %>% rename(Exited_new = Exited),
by = "ID"
) %>%
mutate(
Exited = if_else(!is.na(Exited_new), Exited_new, Exited)
) %>%
select(-Exited_new)
table(submission$Exited)
#submission
write.csv(submission, "~/GitHub/Mineria/submissions queue/para cuando no lleguemos a 3 en un dia/xgboost_imputing_1_v2.csv", row.names = FALSE)
# Reglas para Exited = 0 con confianza > 0.93
reglas_exit0 <- subset(reglas_Noredund, rhs %pin% "Exited=0" & confidence ==0.95)
# ===============================
# 4️⃣ Inicializar vectores de imputación
# ===============================
rows_to_impute_1 <- rep(FALSE, length(data_ar_trans))
rows_to_impute_0 <- rep(FALSE, length(data_ar_trans))
# ===============================
# 5️⃣ Imputar Exited = 1
# ===============================
for(i in seq_along(reglas_exit1)) {
lhs_rule <- lhs(reglas_exit1[i])
match_rows <- is.subset(lhs_rule, data_ar_trans)
rows_to_impute_1 <- rows_to_impute_1 | as.logical(match_rows)
}
# ===============================
# 6️⃣ Imputar Exited = 0
# ===============================
for(i in seq_along(reglas_exit0)) {
lhs_rule <- lhs(reglas_exit0[i])
match_rows <- is.subset(lhs_rule, data_ar_trans)
rows_to_impute_0 <- rows_to_impute_0 | as.logical(match_rows)
}
# ===============================
# 7️⃣ Aplicar imputaciones en data_ar
# ===============================
data_ar_imputed <- data_ar
# Imputar según reglas
data_ar_imputed$Exited[rows_to_impute_1] <- 1
data_ar_imputed$Exited[rows_to_impute_0] <- 0
# Añadir ID
data_ar_imputed$ID <- data[7001:10000, ]$ID
# Seleccionar solo ID y Exited
data_ar_imputed2 <- data_ar_imputed[, c("ID", "Exited")]
# Convertir Exited a "Yes"/"No" y eliminar NA
data_ar_imputed2 <- data_ar_imputed2 %>%
filter(!is.na(Exited)) %>%
mutate(Exited = ifelse(Exited == 1, "Yes", "No"))
table(data_ar_imputed2$Exited)
saveRDS(
data_ar_imputed2,
"~/GitHub/Mineria/DATA/A NUEVOS TEST CON IMPUTADOS DE REPETIDOS/test_df_imputed_AR_01.rds"
)
#aplicamos los imputados
test_df_imputed <- readRDS("~/GitHub/Mineria/DATA/A NUEVOS TEST CON IMPUTADOS DE REPETIDOS/test_df_imputed_AR_01.rds")
library(dplyr)
#ID originales de test
load("~/GitHub/Mineria/DATA/data.RData")
id<-data[7001:10000,]$ID
# Unir por ID y actualizar Exited
submission <- data.frame(ID = id, Exited = pred_kaggle_class)
table(submission$Exited)
submission <- submission %>%
left_join(
test_df_imputed %>% select(ID, Exited) %>% rename(Exited_new = Exited),
by = "ID"
) %>%
mutate(
Exited = if_else(!is.na(Exited_new), Exited_new, Exited)
) %>%
select(-Exited_new)
table(submission$Exited)
# Reglas para Exited = 0 con confianza > 0.93
reglas_exit0 <- subset(reglas_Noredund, rhs %pin% "Exited=0" & confidence ==1)
# ===============================
# 4️⃣ Inicializar vectores de imputación
# ===============================
rows_to_impute_1 <- rep(FALSE, length(data_ar_trans))
rows_to_impute_0 <- rep(FALSE, length(data_ar_trans))
# ===============================
# 5️⃣ Imputar Exited = 1
# ===============================
for(i in seq_along(reglas_exit1)) {
lhs_rule <- lhs(reglas_exit1[i])
match_rows <- is.subset(lhs_rule, data_ar_trans)
rows_to_impute_1 <- rows_to_impute_1 | as.logical(match_rows)
}
# ===============================
# 6️⃣ Imputar Exited = 0
# ===============================
for(i in seq_along(reglas_exit0)) {
lhs_rule <- lhs(reglas_exit0[i])
match_rows <- is.subset(lhs_rule, data_ar_trans)
rows_to_impute_0 <- rows_to_impute_0 | as.logical(match_rows)
}
# ===============================
# 7️⃣ Aplicar imputaciones en data_ar
# ===============================
data_ar_imputed <- data_ar
# Imputar según reglas
data_ar_imputed$Exited[rows_to_impute_1] <- 1
data_ar_imputed$Exited[rows_to_impute_0] <- 0
# Añadir ID
data_ar_imputed$ID <- data[7001:10000, ]$ID
# Seleccionar solo ID y Exited
data_ar_imputed2 <- data_ar_imputed[, c("ID", "Exited")]
# Convertir Exited a "Yes"/"No" y eliminar NA
data_ar_imputed2 <- data_ar_imputed2 %>%
filter(!is.na(Exited)) %>%
mutate(Exited = ifelse(Exited == 1, "Yes", "No"))
table(data_ar_imputed2$Exited)
saveRDS(
data_ar_imputed2,
"~/GitHub/Mineria/DATA/A NUEVOS TEST CON IMPUTADOS DE REPETIDOS/test_df_imputed_AR_01.rds"
)
test_df_imputed <- readRDS("~/GitHub/Mineria/DATA/A NUEVOS TEST CON IMPUTADOS DE REPETIDOS/test_df_imputed_AR_01.rds")
library(dplyr)
#ID originales de test
load("~/GitHub/Mineria/DATA/data.RData")
id<-data[7001:10000,]$ID
# Unir por ID y actualizar Exited
submission <- data.frame(ID = id, Exited = pred_kaggle_class)
table(submission$Exited)
submission <- submission %>%
left_join(
test_df_imputed %>% select(ID, Exited) %>% rename(Exited_new = Exited),
by = "ID"
) %>%
mutate(
Exited = if_else(!is.na(Exited_new), Exited_new, Exited)
) %>%
select(-Exited_new)
table(submission$Exited)
reglas_exit1 <- subset(reglas_Noredund, rhs %pin% "Exited=1" & confidence >= 0.50)
# Reglas para Exited = 0 con confianza > 0.93
reglas_exit0 <- subset(reglas_Noredund, rhs %pin% "Exited=0" & confidence ==1)
# ===============================
# 4️⃣ Inicializar vectores de imputación
# ===============================
rows_to_impute_1 <- rep(FALSE, length(data_ar_trans))
rows_to_impute_0 <- rep(FALSE, length(data_ar_trans))
# ===============================
# 5️⃣ Imputar Exited = 1
# ===============================
for(i in seq_along(reglas_exit1)) {
lhs_rule <- lhs(reglas_exit1[i])
match_rows <- is.subset(lhs_rule, data_ar_trans)
rows_to_impute_1 <- rows_to_impute_1 | as.logical(match_rows)
}
# ===============================
# 6️⃣ Imputar Exited = 0
# ===============================
for(i in seq_along(reglas_exit0)) {
lhs_rule <- lhs(reglas_exit0[i])
match_rows <- is.subset(lhs_rule, data_ar_trans)
rows_to_impute_0 <- rows_to_impute_0 | as.logical(match_rows)
}
# ===============================
# 7️⃣ Aplicar imputaciones en data_ar
# ===============================
data_ar_imputed <- data_ar
# Imputar según reglas
data_ar_imputed$Exited[rows_to_impute_1] <- 1
data_ar_imputed$Exited[rows_to_impute_0] <- 0
# Añadir ID
data_ar_imputed$ID <- data[7001:10000, ]$ID
# Seleccionar solo ID y Exited
data_ar_imputed2 <- data_ar_imputed[, c("ID", "Exited")]
# Convertir Exited a "Yes"/"No" y eliminar NA
data_ar_imputed2 <- data_ar_imputed2 %>%
filter(!is.na(Exited)) %>%
mutate(Exited = ifelse(Exited == 1, "Yes", "No"))
table(data_ar_imputed2$Exited)
saveRDS(
data_ar_imputed2,
"~/GitHub/Mineria/DATA/A NUEVOS TEST CON IMPUTADOS DE REPETIDOS/test_df_imputed_AR_01.rds"
)
test_df_imputed <- readRDS("~/GitHub/Mineria/DATA/A NUEVOS TEST CON IMPUTADOS DE REPETIDOS/test_df_imputed_AR_01.rds")
library(dplyr)
#ID originales de test
load("~/GitHub/Mineria/DATA/data.RData")
id<-data[7001:10000,]$ID
# Unir por ID y actualizar Exited
submission <- data.frame(ID = id, Exited = pred_kaggle_class)
table(submission$Exited)
submission <- submission %>%
left_join(
test_df_imputed %>% select(ID, Exited) %>% rename(Exited_new = Exited),
by = "ID"
) %>%
mutate(
Exited = if_else(!is.na(Exited_new), Exited_new, Exited)
) %>%
select(-Exited_new)
table(submission$Exited)
#submission
write.csv(submission, "~/GitHub/Mineria/submissions queue/para cuando no lleguemos a 3 en un dia/xgboost_imputing_1_v2.csv", row.names = FALSE)
data_ar_trans <- as(data_ar, "transactions")
rules <- apriori(
data_tr,
parameter = list(support = 0.025, confidence = 0.4, maxlen = 5, minlen = 2)
)
# Quitar reglas redundantes
reglas_Noredund <- rules[!is.redundant(rules, measure = "confidence")]
# 3️⃣ Seleccionar reglas de interés
# Reglas para Exited = 1
reglas_exit1 <- subset(reglas_Noredund, rhs %pin% "Exited=1" & confidence >= 0.50)
# Reglas para Exited = 0
reglas_exit0 <- subset(reglas_Noredund, rhs %pin% "Exited=0" & confidence ==1)
rows_to_impute_1 <- rep(FALSE, length(data_ar_trans))
rows_to_impute_0 <- rep(FALSE, length(data_ar_trans))
for(i in seq_along(reglas_exit1)) {
lhs_rule <- lhs(reglas_exit1[i])
match_rows <- is.subset(lhs_rule, data_ar_trans)
rows_to_impute_1 <- rows_to_impute_1 | as.logical(match_rows)
}
for(i in seq_along(reglas_exit0)) {
lhs_rule <- lhs(reglas_exit0[i])
match_rows <- is.subset(lhs_rule, data_ar_trans)
rows_to_impute_0 <- rows_to_impute_0 | as.logical(match_rows)
}
data_ar_imputed <- data_ar
# Imputar según reglas
data_ar_imputed$Exited[rows_to_impute_1] <- 1
data_ar_imputed$Exited[rows_to_impute_0] <- 0
# Añadir ID
data_ar_imputed$ID <- data[7001:10000, ]$ID
# Seleccionar solo ID y Exited
data_ar_imputed2 <- data_ar_imputed[, c("ID", "Exited")]
# Convertir Exited a "Yes"/"No" y eliminar NA
data_ar_imputed2 <- data_ar_imputed2 %>%
filter(!is.na(Exited)) %>%
mutate(Exited = ifelse(Exited == 1, "Yes", "No"))
table(data_ar_imputed2$Exited)
saveRDS(
data_ar_imputed2,
"~/GitHub/Mineria/DATA/A NUEVOS TEST CON IMPUTADOS DE REPETIDOS/test_df_imputed_AR_01.rds"
)
test_df_imputed <- readRDS("~/GitHub/Mineria/DATA/A NUEVOS TEST CON IMPUTADOS DE REPETIDOS/test_df_imputed_AR_01.rds")
library(dplyr)
#ID originales de test
load("~/GitHub/Mineria/DATA/data.RData")
id<-data[7001:10000,]$ID
# Unir por ID y actualizar Exited
submission <- data.frame(ID = id, Exited = pred_kaggle_class)
table(submission$Exited)
submission <- submission %>%
left_join(
test_df_imputed %>% select(ID, Exited) %>% rename(Exited_new = Exited),
by = "ID"
) %>%
mutate(
Exited = if_else(!is.na(Exited_new), Exited_new, Exited)
) %>%
select(-Exited_new)
table(submission$Exited)
