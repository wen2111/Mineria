load("~/GitHub/Mineria/DATA/data.RData")
knitr::opts_chunk$set(echo = TRUE)
library(mice)
library(mice)
library(VIM)  # Para visualizar los datos imputados
datamice <- data
# Identificar tipos de variables
variables_numericas <- names(datamice)[sapply(datamice, is.numeric)]
variables_dicotomicas <- names(datamice)[sapply(datamice, function(x) is.factor(x) && nlevels(x) == 2)]
variables_polinomicas <- names(datamice)[sapply(datamice, function(x) is.factor(x) && nlevels(x) > 2)]
# Variables que no se deben imputar
variables_no_imputar <- c("ID", "Exited")
# Variables a imputar
variables_numericas_imputar <- setdiff(variables_numericas, variables_no_imputar)
variables_dico_imputar <- setdiff(variables_dicotomicas, variables_no_imputar)
variables_poli_imputar <- setdiff(variables_polinomicas, variables_no_imputar)
# Copia de los datos para imputar
datamice_imputado <- datamice
# Crear métodos de imputación
metodos <- make.method(datamice_imputado)
# Asignar métodos de imputación según el tipo de variable
metodos[variables_numericas_imputar] <- "pmm"  # Predictive Mean Matching
metodos[variables_dico_imputar] <- "logreg"    # Regresión logística para dicotómicas
metodos[variables_poli_imputar] <- "polyreg"   # Regresión polinomial para polinómicas
# Configurar la matriz de predictores
pred_mat <- make.predictorMatrix(datamice_imputado)
# Configurar qué variables pueden predecir y ser predecidas
for (var in names(datamice_imputado)) {
if (var %in% variables_numericas_imputar) {
# Esta variable numérica puede ser predicha por otras numéricas imputables
pred_mat[var, variables_numericas_imputar] <- 1
pred_mat[var, var] <- 0  # No usar la variable misma para predecirse
}
# Para excluir ID y Exited de las predictoras y de las imputadas
if (var %in% variables_no_imputar | !var %in% variables_numericas) {
pred_mat[var, ] <- 0  # No usar esta variable para predecir otras
pred_mat[, var] <- 0  # No usar otras variables para predecir esta
}
}
# Realizar la imputación MICE
imputacion <- mice(
datamice_imputado,
m = 5,
maxit = 10,
method = metodos,
predictorMatrix = pred_mat,
seed = 123,
printFlag = TRUE
)
# Completar los datos imputados
datamice_completo <- complete(imputacion, 1)
# Combinar los datos imputados con los originales
datamice_final <- datamice
datamice_final[variables_numericas_imputar] <- datamice_completo[variables_numericas_imputar]
datamice_final[variables_dico_imputar] <- datamice_completo[variables_dico_imputar]
datamice_final[variables_poli_imputar] <- datamice_completo[variables_poli_imputar]
# Visualizar los datos imputados para verificar
aggr_plot <- aggr(datamice_final, col=c('navyblue','red'), numbers=TRUE, sortVars=TRUE, labels=names(datamice_final), cex.axis=.7, gap=3, ylab=c("Histograma de datos faltantes","Patrón"))
print(aggr_plot)
vis_dat(datamice_final)
library(naniar)
library(ggplot2)
library(visdat)
library(dplyr)
library(tidyr)
library(Hmisc)
vis_dat(datamice_final)
density_before_after(data, datamice_final)
density_before_after <- function(before, after) {
require(ggplot2)
require(dplyr)
require(tidyr)
require(purrr)
# Identificar variables numéricas comunes
numeric_vars_before <- before |>
select(where(is.numeric)) |>
names()
numeric_vars_after <- after |>
select(where(is.numeric)) |>
names()
# Variables comunes entre ambos datasets
common_vars <- intersect(numeric_vars_before, numeric_vars_after)
if (length(common_vars) == 0) {
stop("No hay variables numéricas comunes entre los datasets")
}
# Crear datos combinados
density_df <- map_dfr(common_vars, function(var) {
data.frame(
variable = var,
value = c(before[[var]], after[[var]]),
dataset = rep(c("Original", "Imputado"),
c(nrow(before), nrow(after)))
)
}) |>
filter(!is.na(value))
# Crear el gráfico
ggplot(density_df, aes(x = value, color = dataset, fill = dataset)) +
facet_wrap(~variable, scales = "free") +
geom_density(alpha = 0.3) +
scale_color_manual(values = c("#1f77b4", "#ff7f0e")) +
scale_fill_manual(values = c("#1f77b4", "#ff7f0e")) +
labs(title = "Comparación de Densidades: Original vs Imputado",
x = "Valores",
y = "Densidad") +
theme_minimal() +
theme(legend.position = "bottom")
}
mass_before_after <- function(before, after, max_categories = 10) {
require(ggplot2)
require(dplyr)
require(tidyr)
require(purrr)
# Identificar variables categóricas comunes
categorical_vars_before <- before |>
select(where(~ is.factor(.) | is.character(.))) |>
names()
categorical_vars_after <- after |>
select(where(~ is.factor(.) | is.character(.))) |>
names()
# Variables comunes entre ambos datasets
common_vars <- intersect(categorical_vars_before, categorical_vars_after)
if (length(common_vars) == 0) {
stop("No hay variables categóricas comunes entre los datasets")
}
# Crear datos combinados
mass_df <- map_dfr(common_vars, function(var) {
# Convertir a factor si es character
before_vec <- if(is.character(before[[var]])) {
as.factor(before[[var]])
} else {
before[[var]]
}
after_vec <- if(is.character(after[[var]])) {
as.factor(after[[var]])
} else {
after[[var]]
}
# Calcular proporciones
prop_before <- proportions(table(before_vec))
prop_after <- proportions(table(after_vec))
data.frame(
variable = var,
category = c(names(prop_before), names(prop_after)),
proportion = c(prop_before, prop_after),
dataset = rep(c("Original", "Imputado"),
c(length(prop_before), length(prop_after)))
)
}) |>
filter(!is.na(category))
# Filtrar categorías si hay demasiadas
if (max_categories > 0) {
mass_df <- mass_df |>
group_by(variable) |>
slice_max(proportion, n = max_categories) |>
ungroup()
}
# Crear el gráfico
ggplot(mass_df, aes(x = category, y = proportion,
color = dataset, fill = dataset)) +
facet_wrap(~variable, scales = "free") +
geom_col(alpha = 0.6, width = 0.7, position = "dodge") +
scale_color_manual(values = c("#1f77b4", "#ff7f0e")) +
scale_fill_manual(values = c("#1f77b4", "#ff7f0e")) +
labs(title = "Comparación de Distribuciones Categóricas: Original vs Imputado",
x = "Categorías",
y = "Proporción") +
theme_minimal() +
theme(legend.position = "bottom",
axis.text.x = element_text(angle = 45, hjust = 1))
}
density_before_after(data, datamice_final)
mass_before_after
mass_before_after(data, datamice_final)
data_imputado<-datamice_final
getwd()
rm(list = setdiff(ls(), "data_imputado"))
save(data_imputado, file = "data_imputado.RData")
load("~/Documents/GitHub/Mineria/DATA/data.RData")
setwd("~/GitHub/Mineria/DATA")
load("~/Documents/GitHub/Mineria/DATA/data.RData")
load("data.RData")
getwd()
load("/data.RData")
load("~/GitHub/Mineria/DATA/data.RData")
load("~/GitHub/Mineria/DATA/data.RData")
