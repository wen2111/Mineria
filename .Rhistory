}
lapply(list.of.packages, require, character.only = T)
rm(list.of.packages, new.packages)
# Data export ==================================================================
source("99_DadesRoba.R")
## Calculamos las distancias
### Euclidean
distancia <- dist(dataNum, method = "euclidean")
## Generamos la agrupación
### single
agrSingle <- hclust(distancia, method = "single")
### complete
agrComplete <- hclust(distancia, method = "complete")
### average
agrAverage <- hclust(distancia, method = "average")
### mcquitty
agrMcquitty <- hclust(distancia, method = "mcquitty")
### median
agrMedian <- hclust(distancia, method = "median")
### centroid
agrCentroid <- hclust(distancia, method = "centroid")
### ward.D o ward.D2
agrWard <- hclust(distancia, method = "ward.D2")
## Graficamos el dendograma ----------------------------------------------------
library(ggplot2)
library(ggdendro)
library(gridExtra)
plot_dendrogram <- function(hclust_obj, method_name) {
dendro_data <- ggdendro::dendro_data(hclust_obj)
ggplot(ggdendro::segment(dendro_data)) +
geom_segment(aes(x = x, y = y, xend = xend, yend = yend)) +
theme_minimal() +
ggtitle(method_name) +
theme(axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
panel.grid = element_blank())
}
setwd("~/Documents/2024-2025/segon semestre/multi/Laboratoris-20250306")
# Data export ==================================================================
source("99_DadesRoba.R")
source("99_DadesRoba.R")
library(ggplot2)
library(ggdendro)
library(gridExtra)
dataNum <- dades[, varNum]
## Calculamos las distancias
### Euclidean
distancia <- dist(dataNum, method = "euclidean")
## Generamos la agrupación
### single
agrSingle <- hclust(distancia, method = "single")
### complete
agrComplete <- hclust(distancia, method = "complete")
### average
agrAverage <- hclust(distancia, method = "average")
### mcquitty
agrMcquitty <- hclust(distancia, method = "mcquitty")
### median
agrMedian <- hclust(distancia, method = "median")
### centroid
agrCentroid <- hclust(distancia, method = "centroid")
### ward.D o ward.D2
agrWard <- hclust(distancia, method = "ward.D2")
## Graficamos el dendograma ----------------------------------------------------
library(ggplot2)
library(ggdendro)
library(gridExtra)
### Función para convertir hclust a ggplot
plot_dendrogram <- function(hclust_obj, method_name) {
dendro_data <- ggdendro::dendro_data(hclust_obj)
ggplot(ggdendro::segment(dendro_data)) +
geom_segment(aes(x = x, y = y, xend = xend, yend = yend)) +
theme_minimal() +
ggtitle(method_name) +
theme(axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
panel.grid = element_blank())
}
dendrograms <- list(
plot_dendrogram(agrSingle, "Single"),
plot_dendrogram(agrComplete, "Complete"),
plot_dendrogram(agrAverage, "Average"),
plot_dendrogram(agrMcquitty, "McQuitty"),
plot_dendrogram(agrMedian, "Median"),
plot_dendrogram(agrCentroid, "Centroid"),
plot_dendrogram(agrWard, "Ward.D2")
)
### Lista de dendrogramas con nombres
dendrograms <- list(
plot_dendrogram(agrSingle, "Single"),
plot_dendrogram(agrComplete, "Complete"),
plot_dendrogram(agrAverage, "Average"),
plot_dendrogram(agrMcquitty, "McQuitty"),
plot_dendrogram(agrMedian, "Median"),
plot_dendrogram(agrCentroid, "Centroid"),
plot_dendrogram(agrWard, "Ward.D2")
)
dissimMatrix <- daisy(dades[, c(varNum, varCat)], metric = "gower", stand = TRUE)
## Generamos la agrupación
### single
agrSingle <- hclust(distMatrix, method = "single")
# MIXED DATASETS ===============================================================
### Use Gower Index
dissimMatrix <- daisy(dades[, c(varNum, varCat)], metric = "gower", stand = TRUE)
plot(agrWard, main = "H.Clustering with euclidean distance and method WARD")
rect.hclust(agrWard, k = 3, border = 3)
info <- data.frame(metricas = c("Single", "Complete", "Average", "McQuitty", "Median",
"Centroid", "Ward"),
correlaciones = c(cor(distMatrix, cophenetic(agrSingle)),
cor(distMatrix, cophenetic(agrComplete)),
cor(distMatrix, cophenetic(agrAverage)),
cor(distMatrix, cophenetic(agrMcquitty)),
cor(distMatrix, cophenetic(agrMedian)),
cor(distMatrix, cophenetic(agrCentroid)),
cor(distMatrix, cophenetic(agrWard))))
# podem veure el diagrama
# MIXED DATASETS ===============================================================
### Use Gower Index
dissimMatrix <- daisy(dades[, c(varNum, varCat)], metric = "gower", stand = TRUE)
list.of.packages = c("dplyr", "reshape2", "tidyr", "ggplot2", "stats",
"cluster", "factoextra", "colorspace", "patchwork", "dendextend",
"tidyverse", "ggpubr", "NbClust", "HDclassif", "clValid",
"mclust")
#Els ultims 4 paquets son aquells utilitzats per clustering
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages) > 0) {
install.packages(new.packages)
}
rm(list.of.packages, new.packages)
# Data export ==================================================================
source("99_DadesRoba.R")
list.of.packages = c("dplyr", "fpc", "reshape2", "tidyr", "ggplot2", "stats",
"cluster", "factoextra", "colorspace", "patchwork",
"tidyverse", "ggpubr", "NbClust", "HDclassif", "clustMixType")
#Primera linea per visualització de clustering
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages) > 0) {
install.packages(new.packages)
}
rm(list.of.packages, new.packages)
# Data export ==================================================================
# Cargamos la base de datos
# https://archive.ics.uci.edu/ml/datasets/Wine
#Set your work directory and upload the file there
data(wine); data <- wine; rm(wine)
https://archive.ics.uci.edu/ml/datasets/Wine
names <- c('Cultivar','Alcohol','Malic_acid' , 'Ash', 'Alcalinity_ash', 'Magnesium',
'Total_phenols', 'Flavanoids', 'Nonflavanoid_phenols', 'Proanthocyanins',
'Color_intensity', 'Hue', 'OD280_OD315_diluted_wines','Proline')
colnames(data) <- names; summary(data)
# Data export ==================================================================
# Cargamos la base de datos
# https://archive.ics.uci.edu/ml/datasets/Wine
#Set your work directory and upload the file there
data(wine); data <- wine; rm(wine)
data(wine)
list.of.packages = c("dplyr", "fpc", "reshape2", "tidyr", "ggplot2", "stats",
"cluster", "factoextra", "colorspace", "patchwork",
"tidyverse", "ggpubr", "NbClust", "HDclassif", "clustMixType")
#Primera linea per visualització de clustering
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages) > 0) {
install.packages(new.packages)
}
rm(list.of.packages, new.packages)
data(wine)
# Data export ==================================================================
# Cargamos la base de datos
# https://archive.ics.uci.edu/ml/datasets/Wine
#Set your work directory and upload the file there
data(wine)
data <- wine; rm(wine)
data <- wine
# Data export ==================================================================
# Cargamos la base de datos
# https://archive.ics.uci.edu/ml/datasets/Wine
#Set your work directory and upload the file there
data(wine)
setwd("~/Documents/2024-2025/segon semestre/multi/Laboratoris-20250306/wine")
# Data export ==================================================================
# Cargamos la base de datos
# https://archive.ics.uci.edu/ml/datasets/Wine
#Set your work directory and upload the file there
data(wine)
data <- wine
# Data export ==================================================================
# Cargamos la base de datos
# https://archive.ics.uci.edu/ml/datasets/Wine
#Set your work directory and upload the file there
data(wine.data)
setwd("~/Documents/2024-2025/segon semestre/multi/airbnb 2")
knitr::opts_chunk$set(echo = TRUE)
library(readr)
airbnb <- read.csv("Airbnb_Open_Data.csv")
head(airbnb)
View(airbnb)
View(airbnb)
airbnb<-airbnb[,-c(8,9,10,11,26)]
airbnb
summary(airbnb)
l<-airbnb$Construction.year
summary(l)
count(l)
table(l)
max(table(l))
r<-airbnb$last.review
table(r)
max(table(r))
s<-airbnb$neighbourhood.group
table(s)
airbnb<-airbnb[,-c(8,9,10,11,26)]
airbnb2<-airbnb[,-c(8,9,10,11,26)]
summary(airbnb2)
airbnb3<-airbnb2[airbnb2$neighbourhood.group%in%c("Bronx", "State Island"), ]
nrow(airbnb3)
nrow(airbnb2$neighbourhood.group=="Bronx")
nrow(airbnb2$neighbourhood.group="Bronx")
nrow(airbnb3)
table(airbnb2$neighbourhood.group)
2712+955
airbnb3<-airbnb2[airbnb2$neighbourhood.group%in%c("Bronx", "Staten Island"), ]
nrow(airbnb3)
install.packages("dbplyr")
library(dbplyr)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("TxDb.Mmusculus.UCSC.mm10.knownGene")
library(Mus.musculus)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("Mus.musculus")
R.version.string
install.packages("installr")  # Solo en Windows
library(installr)
updateR()
knitr::opts_chunk$set(echo = TRUE)
all.rpkm<-read.delim2("GSE116583_transplant.am.htseq.all.rpkm.txt", header=T, sep="\t" ,dec=".")
x<- DGEList(count=all.rpkm, group=c("control",4), rep("2h",4),rep("24h",4))
qt(0.025,138)
0.0035/0.0022
qt(0.025,138)
k<-4
dreta<-0.03226/(1-0.03226)
(((2.62729)^2)/k)*dreta
k<-5
(((2.62729)^2)/k)*dreta
k<-6
(((2.62729)^2)/k)*dreta
qt(0.025,197)
qt(0.025,198)
SQET<-211.204
sqet1<-95.098
sqet2<-100.118ç
sqet2<-100.118
k<-3
T<-2010-1970
T
t<-T+1
denom<-(SQET-(sqet2+sqet1))/3
num<-(sqet1+sqet2)/(t-2*k)
denom/num
num<-3*0.66-2*0.125
denom<-0.0011+0.0012-2*0.0002
den<-sqrt(denom)
num<-num-3
num/den
numerador<-0.66*3-0.125*2-3
denom<-4*0.0011+9*0.0012-12*0.0002
den<-sqrt(denom)
numerador/den
0.5219
1-0.5219
0.3528+0.2591
1-0.2456615
0.2456615/(0.6089679 - 0.2456615)
(0.2456615^2)/(0.6089679(0.6089679 - 0.2456615))
(0.2456615^2)/(0.6089679*(0.6089679 - 0.2456615))
0.6761827/0.2456615
0.2727764/0.2456615
1-0.4077
data <- data.frame(
A = rnorm(100),
B = rnorm(100),
C = rnorm(100),
D = rnorm(100)
)
data
dim(data)
R <- cor(data)
dim(R)
set.seed(123)
data <- data.frame(
A = rnorm(100),
B = rnorm(100),
C = rnorm(100),
D = rnorm(100)
)
R <- cor(data)
View(R)
P<-solve(R)
View(P)
p <- ncol(P)
partial_cor <- matrix(NA, nrow = p, ncol = p)
colnames(partial_cor) <- rownames(partial_cor) <- colnames(data)
View(partial_cor)
round(partial_cor, 3)
# Calcular correlaciones parciales
for (i in 1:p) {
for (j in 1:p) {
if (i == j) {
partial_cor[i, j] <- 1
} else {
partial_cor[i, j] <- -P[i, j] / sqrt(P[i, i] * P[j, j])
}
}
}
round(partial_cor, 3)
set.seed(1)
n <- 100
n <- 100
p <- 5
X <- matrix(rnorm(n * p), n, p)
colnames(X) <- paste0("V", 1:p)
# Pearson entre V1 y V2
cor(X[,1], X[,2])
pcor(X)$estimate
library(ppcor)
pcor(X)$estimate
pcor.test(X[,1],X[,2],X[,3:5])
pcor(X[,1],X[,2],X[,3:5])
install.packages('epibasix')
library(epibasix)
tabla <- matrix(c(7,125,8,860),2,2,byrow=T) # Tabla 2
results <- epi2x2(tabla)
attach(results)
x
X
View(tabla)
View(results)
#CIL=Confidence Interval Lower; CIU=Confidence Interval Upper
# rdCo=Risk Difference
# Estimación puntual e IC para la DR
rdCo;rdCo.CIL;rdCo.CIU
# Estimación puntual e IC para el RP
RP;RP.CIL;RP.CIU
# Estimación puntual e IC para el RP
RP;RP.CIL;RP.CIU
# Estimación puntual e IC para el RP
RP;RP.CIL;RP.CIU
# Estimación puntual e IC para el RP
RP;RP.CIL;RP.CIU
# Estimación puntual e IC para el OR
OR;OR.CIL;OR.CIU
detach(results)
# Estimación puntual e IC para el RP
RP;RP.CIL;RP.CIU
library(epibasix)
tabla <- matrix(c(7,125,8,860),2,2,byrow=T) # Tabla 2
results <- epi2x2(tabla)
attach(results) #Et dona tots els resultats posibles
#CIL=Confidence Interval Lower; CIU=Confidence Interval Upper
# rdCo=Risk Difference
# Estimación puntual e IC para la DR
rdCo;rdCo.CIL;rdCo.CIU
# Estimación puntual e IC para el RP
RP;RP.CIL;RP.CIU
View(results)
# Estimación puntual e IC para el RP
RR;RR.CIL;RR.CIU
knitr::opts_chunk$set(echo = TRUE)
serie=window(ts(read.table("co2IndUSA.dat"),start=1990,freq=12),start=2009)
serie=window(ts(read.table("co2IndUSA.dat"),start=1990,freq=12),start=2009)
serie=window(ts(read.table("CO2IndUSA.dat"),start=1990,freq=12),start=2009)
serie=window(ts(read.table("CO2IndUSA.dat"),start=1990,freq=12),start=2009)
serie
length(serie)
start(serie)
end(serie)
frequency(serie)
(hw<-HoltWinters(serie,alpha=NULL,beta=FALSE,gamma=FALSE,seasonal="additive"))
#ts.plot(fitted(hw),serie,col=c(1,3),lwd=c(1,3))
ts.plot(fitted(hw)[,1],serie,col=c(3,1),lwd=c(3,1))
plot(serie, main="Emisiones de CO2 del sector industrial en USA", ylab="millones de Tm")
abline(v=1985:2020,lty=3,col=4)
m<-mean(serie)
abline(h=m,lty=3, col=2)
summary(serie)
pred=predict(hw,24) #10
ts.plot(serie, pred,col=c(1,2),lwd=c(1,2))
serie = window(ts(co2,start=1959,freq=12),start=1959)
plot(serie, ylab = expression("Atmospheric concentration of CO"[2]), las = 1)
title(main = "co2 data set")
par(mfrow=c(2,3))
tuneS1<-function(par){
hw1<-HoltWinters(serie,alpha=par,beta=F,gamma=F)
mean((serie-fitted(hw1)[,1])^2)
}
par=0.5
sol<-optim(par,tuneS1,method="L-BFGS-B",lower=1e-4,upper=0.9999)
hw1<-HoltWinters(serie,alpha=sol$par,beta=F,gamma=F)
phw1<-predict(hw1,24)
ts.plot(serie,phw1,hw1$fitted[,1],col=c(1,2,3),main=paste0("(1)ANN MSE=",round(sol$value,4)))
tuneS2<-function(par){
hw2<-HoltWinters(serie,alpha=par[1],beta=par[2],gamma=F)
mean((serie-fitted(hw2)[,1])^2)
}
par=c(0.5,0.5)
sol<-optim(par,tuneS2,method="L-BFGS-B",lower=c(1e-4,1e-4),upper=c(0.9999,0.9999))
hw2<-HoltWinters(serie,alpha=sol$par[1],beta=sol$par[2],gamma=F)
phw2<-predict(hw2,24)
ts.plot(serie,phw2,hw2$fitted[,1],col=c(1,2,3),main=paste0("(2)AAN MSE=",round(sol$value,4)))
tuneS3<-function(par){
hw3<-HoltWinters(serie,alpha=par[1],beta=FALSE,gamma=par[2])
mean((serie-fitted(hw3)[,1])^2)
}
par=c(0.5,0.5)
sol<-optim(par,tuneS3,method="L-BFGS-B",lower=c(1e-4,1e-4),upper=c(0.9999,0.9999))
hw3<-HoltWinters(serie,alpha=sol$par[1],beta=FALSE,gamma=sol$par[2])
phw3<-predict(hw3,24)
ts.plot(serie,phw3,hw3$fitted[,1],col=c(1,2,3),main=paste0("(3)ANA MSE=",round(sol$value,4)))
tuneS4<-function(par){
hw4<-HoltWinters(serie,alpha=par[1],beta=par[2],gamma=par[3])
mean((serie-fitted(hw4)[,1])^2)
}
par=c(0.5,0.5,0.5)
sol<-optim(par,tuneS4,method="L-BFGS-B",lower=c(1e-4,1e-4,1e-4),upper=c(0.9999,0.9999,0.9999))
hw4<-HoltWinters(serie,alpha=sol$par[1],beta=sol$par[2],gamma=sol$par[3])
phw4<-predict(hw4,24)
ts.plot(serie,phw4,hw4$fitted[,1],col=c(1,2,3),main=paste0("(4)AAA MSE=",round(sol$value,4)))
tuneS5<-function(par){
hw5<-HoltWinters(serie,alpha=par[1],beta=FALSE,gamma=par[2],seasonal="multip")
mean((serie-fitted(hw5)[,1])^2)
}
par=c(0.5,0.5)
sol<-optim(par,tuneS5,method="L-BFGS-B",lower=c(1e-4,1e-4),upper=c(0.9999,0.9999))
hw5<-HoltWinters(serie,alpha=sol$par[1],beta=FALSE,gamma=sol$par[2],seasonal="m")
phw5<-predict(hw5,24)
ts.plot(serie,phw5,hw5$fitted[,1],col=c(1,2,3),main=paste0("(5)ANM MSE=",round(sol$value,4)))
tuneS6<-function(par){
hw6<-HoltWinters(serie,alpha=par[1],beta=par[2],gamma=par[3],seasonal="multip")
mean((serie-fitted(hw6)[,1])^2)
}
par=c(0.3,0.1,0.1)
sol<-optim(par,tuneS6,method="L-BFGS-B",lower=c(1e-4,1e-4,1e-4),upper=c(0.9999,0.9999,0.9999))
hw6<-HoltWinters(serie,alpha=sol$par[1],beta=sol$par[2],gamma=sol$par[3],seasonal="m")
phw6<-predict(hw6,24)
ts.plot(serie,phw6,hw6$fitted[,1],col=c(1,2,3),main=paste0("(6)AAM MSE=",round(sol$value,4)))
serie=window(ts(read.table("airbcn.dat")[,1]/1000,start=1990,freq=12),start=2009)
plot(serie,main="Miles de pasajeros de lineas aereas internacionales (BCN-Prat)",ylim=c(0,4100))
abline(v=1990:2020,col=4,lty=3)
par(mfrow=c(2,3))
tuneS1<-function(par){
hw1<-HoltWinters(serie,alpha=par,beta=F,gamma=F)
mean((serie-fitted(hw1)[,1])^2)
}
par=0.5
sol<-optim(par,tuneS1,method="L-BFGS-B",lower=1e-4,upper=0.9999)
hw1<-HoltWinters(serie,alpha=sol$par,beta=F,gamma=F)
phw1<-predict(hw1,24)
ts.plot(serie,phw1,hw1$fitted[,1],col=c(1,2,3),main=paste0("(1)ANN MSE=",round(sol$value,4)))
tuneS2<-function(par){
hw2<-HoltWinters(serie,alpha=par[1],beta=par[2],gamma=F)
mean((serie-fitted(hw2)[,1])^2)
}
par=c(0.5,0.5)
sol<-optim(par,tuneS2,method="L-BFGS-B",lower=c(1e-4,1e-4),upper=c(0.9999,0.9999))
hw2<-HoltWinters(serie,alpha=sol$par[1],beta=sol$par[2],gamma=F)
phw2<-predict(hw2,24)
ts.plot(serie,phw2,hw2$fitted[,1],col=c(1,2,3),main=paste0("(2)AAN MSE=",round(sol$value,4)))
tuneS3<-function(par){
hw3<-HoltWinters(serie,alpha=par[1],beta=FALSE,gamma=par[2])
mean((serie-fitted(hw3)[,1])^2)
}
par=c(0.5,0.5)
sol<-optim(par,tuneS3,method="L-BFGS-B",lower=c(1e-4,1e-4),upper=c(0.9999,0.9999))
hw3<-HoltWinters(serie,alpha=sol$par[1],beta=FALSE,gamma=sol$par[2])
phw3<-predict(hw3,24)
ts.plot(serie,phw3,hw3$fitted[,1],col=c(1,2,3),main=paste0("(3)ANA MSE=",round(sol$value,4)))
tuneS4<-function(par){
hw4<-HoltWinters(serie,alpha=par[1],beta=par[2],gamma=par[3])
mean((serie-fitted(hw4)[,1])^2)
}
par=c(0.5,0.5,0.5)
sol<-optim(par,tuneS4,method="L-BFGS-B",lower=c(1e-4,1e-4,1e-4),upper=c(0.9999,0.9999,0.9999))
hw4<-HoltWinters(serie,alpha=sol$par[1],beta=sol$par[2],gamma=sol$par[3])
phw4<-predict(hw4,24)
ts.plot(serie,phw4,hw4$fitted[,1],col=c(1,2,3),main=paste0("(4)AAA MSE=",round(sol$value,4)))
tuneS5<-function(par){
hw5<-HoltWinters(serie,alpha=par[1],beta=FALSE,gamma=par[2],seasonal="multip")
mean((serie-fitted(hw5)[,1])^2)
}
par=c(0.5,0.5)
sol<-optim(par,tuneS5,method="L-BFGS-B",lower=c(1e-4,1e-4),upper=c(0.9999,0.9999))
hw5<-HoltWinters(serie,alpha=sol$par[1],beta=FALSE,gamma=sol$par[2],seasonal="m")
phw5<-predict(hw5,24)
ts.plot(serie,phw5,hw5$fitted[,1],col=c(1,2,3),main=paste0("(5)ANM MSE=",round(sol$value,4)))
tuneS6<-function(par){
hw6<-HoltWinters(serie,alpha=par[1],beta=par[2],gamma=par[3],seasonal="multip")
mean((serie-fitted(hw6)[,1])^2)
}
par=c(0.3,0.1,0.1)
sol<-optim(par,tuneS6,method="L-BFGS-B",lower=c(1e-4,1e-4,1e-4),upper=c(0.9999,0.9999,0.9999))
hw6<-HoltWinters(serie,alpha=sol$par[1],beta=sol$par[2],gamma=sol$par[3],seasonal="m")
phw6<-predict(hw6,24)
ts.plot(serie,phw6,hw6$fitted[,1],col=c(1,2,3),main=paste0("(6)AAM MSE=",round(sol$value,4)))
setwd("~/Documents/GitHub/Mineria")
load("~/Documents/GitHub/Mineria/DATA/data.RData")
load("~/Documents/GitHub/Mineria/DATA/HistAED.RData")
load("~/Documents/GitHub/Mineria/DATA/data.RData")
summary(data)
